[{"body":"移居芬兰生活后，不知什么时候开始有了过敏性鼻炎的症状。随着每年春季的到来，过敏症状愈发加重，若是碰到花粉浓度高的时候，症状会更明显。即便现在花粉的浓度不高，但每天依然不断擤鼻涕，眼睛干涩、发红并且非常痒。我现在每天进行鼻腔冲洗，但效果仍然有限。最终不得不选择药物来缓解这些不适。\n接下来，我介绍一些芬兰药店中常见的抗过敏药物，帮助大家更好地应对过敏性鼻炎。\n过敏性鼻炎 过敏性鼻炎（Allergic Rhinitis）是一种由免疫系统对外部过敏原过度反应引起的疾病。常见的过敏原包括花粉、尘螨、动物皮屑、霉菌等。当这些过敏原进入我们的鼻腔或眼部时，免疫系统便会过度反应，释放一种叫做组胺的化学物质。组胺的释放会引起鼻部和眼部的炎症反应，导致流鼻涕、鼻塞、打喷嚏、眼睛瘙痒、红肿和流泪等症状。\n组胺在正常情况下是身体防御机制的一部分，帮助调节免疫反应和胃肠道功能。但当免疫系统对某些物质发生错误反应时，它会过度释放组胺，从而导致过敏症状的出现。\n在芬兰，春夏季节，尤其是桦树、草类和艾蒿的花粉浓度较高，因此它们是过敏性鼻炎的主要诱因。这些花粉的浓度较高，并且持续时间较长，导致过敏反应发生得更为频繁。除此之外，芬兰的空气干燥也是过敏症状加重的一个因素，特别是在冬季和春季转换时，室内外的干燥空气会加重鼻腔黏膜的刺激，使得过敏性鼻炎的症状更加明显。对于刚到芬兰的朋友来说，这种天气变化和空气干燥可能是一个全新的挑战，不仅花粉浓度较高，而且空气中的湿度较低，容易导致鼻腔更加干燥、发痒，症状更为明显。\n抗过敏药物的种类 针对过敏性鼻炎，常见的药物分为两大类：抗组胺药（Antihistamines）和鼻用糖皮质激素（Nasal Corticosteroids）。\n由于过敏反应的主要原因是组胺的释放，抗组胺药物通过直接抑制组胺与受体结合的作用，快速缓解过敏症状。这类药物作用明确，药效迅速，能够有效缓解鼻塞、流鼻涕、打喷嚏以及眼睛瘙痒等不适。\n而糖皮质激素则通过调节免疫系统，减少免疫细胞的过度反应，从而缓解由过敏引起的炎症和不适。糖皮质激素的药效通常较慢，但它们对于长期或严重的过敏症状尤其有效，能有效控制和减轻持续性的过敏反应。\n抗组胺药能够快速缓解过敏症状，糖皮质激素适合中长期过敏，药效较慢但能持续有效。\n药物介绍 接下来介绍几个芬兰药房中相关的药物，具体请咨询店内医生建议。\nMometason Orion 是芬兰Orion制药公司生产，属于鼻用糖皮质激素类药物（也称为局部类固醇），它通过减少鼻腔内的炎症反应来缓解过敏性鼻炎和鼻息肉的症状。它通过减轻鼻腔炎症来缓解鼻塞、流涕、打喷嚏等症状。成人通常每天在每个鼻孔喷雾两次，症状缓解后可减少至每天一次。常见副作用包括鼻出血、鼻腔灼热感和上呼吸道感染。\nDymista 结合了抗组胺药和类固醇药物，用于缓解由过敏性鼻炎引起的症状，如流涕、打喷嚏、鼻塞和鼻痒。成人通常每日喷雾两次，每次每个鼻孔一次。该药物能够有效减轻鼻腔的过敏反应和炎症。常见副作用包括鼻出血和头痛。\n另外，在过敏相关区域，还可以找到专门缓解眼睛红肿和瘙痒的一些眼药，帮助减轻眼部不适。\n总结 以上基于我的经验，希望大家不被过敏症状困扰，在芬兰可以尽情享受春季的风景。如果你有任何缓解过敏的有效治疗方法，欢迎留言与大家分享。让我们一起在芬兰过得更舒适，呼吸更自在！\n","link":"https://mengwoods.github.io/cn/post/wechat/2025/2025-05-04-allergic/","section":"post","tags":null,"title":"芬兰药店的一些抗过敏性鼻炎药物介绍"},{"body":"一、为什么腰围能反映内脏脂肪？ 简单来说：\n腰围粗大，肚子隆起，往往意味着——包裹器官周围的脂肪正在默默堆积。内脏脂肪不同于皮下脂肪，它紧贴肝脏、胰腺等重要器官，随着脂肪的增多，可能引发胰岛素抵抗、脂肪肝、高血糖、动脉硬化等一系列健康问题。这些问题会逐渐损害心血管、肝脏等器官，增加患糖尿病、高血压、冠心病等疾病的风险。因此，腰围的变化不容忽视，它直接反映了内脏脂肪对身体健康的影响。\n内脏脂肪之所以会引发这么多健康问题，主要是因为它不仅仅是“存储脂肪”，还会分泌多种有害物质，如炎症因子和激素，这些物质会干扰身体正常的代谢过程。首先，内脏脂肪会导致胰岛素抵抗，使得血糖难以被有效利用，增加了患糖尿病的风险。其次，它还会释放脂肪酸进入血液，促使动脉硬化，增加心血管疾病的风险。此外，内脏脂肪的堆积还会导致脂肪肝和肝脏功能紊乱，进一步加重身体的负担。总的来说，内脏脂肪不仅是体内的“隐形炸弹”，还是各种代谢疾病的罪魁祸首。\n二、腰围多少，算危险？ 中国成人标准警戒线一览表：\n性别 警戒线（一般风险） 高风险（特别警惕） 男性 ≥90厘米 ≥100厘米 女性 ≥85厘米 ≥90厘米 《中国2型糖尿病防治指南（2013年版）》\n根据该标准，男性腰围≥90厘米、女性腰围≥85厘米时，已经属于一般风险范围，表明身体的脂肪积累可能开始影响健康；而男性腰围≥100厘米、女性腰围≥90厘米时，则进入高风险区间，健康风险大幅提升，尤其是糖尿病和心血管问题的发生几率显著增加。\n量腰围时，建议站直自然呼吸，并在肚脐水平处，找出最细的部位进行测量。这个位置能更准确地反映内脏脂肪的积累情况，有助于评估健康风险。\n三、为什么腰围悄悄变粗？ 以下是腰围变粗的一些因素：\n【饮食】甜食、饮料、外卖泛滥 → 糖分脂肪堆积 【运动】久坐不动 → 新陈代谢下降 【压力】焦虑熬夜 → 皮质醇飙升，促脂肪集中腹部 【年龄】基础代谢率每10年下降5%+ 【遗传】家族型腹型肥胖 腰围变粗的原因主要与饮食、运动、压力、年龄和遗传因素有关。高糖高脂的饮食（如甜食、饮料和外卖）会导致脂肪堆积，缺乏运动则使新陈代谢减缓，导致脂肪更容易积聚在腹部。长期的压力和熬夜会使体内皮质醇升高，促使脂肪集中在腹部。随着年龄增长，基础代谢率下降，也使得腹部脂肪容易堆积。此外，遗传因素也可能让一些人更容易出现腹型肥胖。\n四、如何科学减少内脏脂肪？ ✅ 饮食 多吃：蛋白质（鸡胸肉、鱼虾、豆制品）、纤维（蔬菜、全谷物） 少吃：甜食、油炸、重加工食品 控制进食窗口：比如尝试16/8轻断食法 ✅ 运动 力量训练（深蹲/硬拉/俯卧撑）每周3次 高强度间歇训练（HIIT）每周2次 保持日行8000步以上 ✅ 睡眠+情绪管理 每晚7-9小时高质量睡眠 学会释放压力（冥想、呼吸法、正念训练） 科学减少内脏脂肪需要从饮食、运动和生活习惯等多方面入手。首先，在饮食方面，建议多摄入优质蛋白质（如鸡胸肉、鱼虾、豆制品）和富含纤维的食物（如蔬菜、全谷物），有助于增强饱腹感，减少脂肪积累。同时，减少甜食、油炸食品和重加工食品的摄入，避免过多热量摄入。还可以尝试16/8轻断食法，控制每日进食时间，帮助降低内脏脂肪。\n其次，运动是减少内脏脂肪的关键。每周进行3次力量训练（如深蹲、硬拉、俯卧撑），可以增强肌肉，提高基础代谢率，帮助燃烧脂肪。同时，每周进行2次高强度间歇训练（HIIT），可以高效燃脂，特别是减少腹部脂肪。日常保持每天8000步以上的步行量，也是简单有效的减脂方法。\n最后，保持良好的睡眠和情绪管理同样重要。每晚保证7-9小时的高质量睡眠，有助于恢复身体代谢，控制脂肪存储。学会释放压力，可以通过冥想、深呼吸、正念训练等方式，减少压力激素皮质醇的分泌，从而避免脂肪在腹部的积聚。通过这些综合性的措施，可以科学有效地减少内脏脂肪，改善健康。\n五、为未来的自己，今天开始改变 🌿 为了身体健康，从现在开始——\n管住嘴，迈开腿； 睡得好，心情稳； 关心腰围，就是关心未来的自己。 ","link":"https://mengwoods.github.io/cn/post/wechat/2025/2025-04-27-wrist/","section":"post","tags":null,"title":"腰围多少算超标？警惕糖尿病和心血管问题的隐形信号"},{"body":"有没有发现，孩子越小，越容易被惩罚和威胁“管住”；可孩子越大，越是说一句顶十句，越是越管越叛逆。\n在亲子教育中，许多家长习惯用惩罚手段来应对孩子的问题行为，但大多数父母都忽略了一个关键问题：惩罚从来教不会孩子自律，只会让他们学会对抗。\n今天这篇文章，我想跟你分享比惩罚更有效和更温和的方法，不仅可以避免孩子产生逆反情绪，还能帮助他们建立责任感和自我管理能力。不发火、不威胁，也能让孩子学会选择、学会自律、学会成长。\n1. 自然后果（Natural Consequences） 自然后果指的是生活中自然发生、不依赖家长干预的结果。比如，不穿外套就会冷，食物不吃就会饿，玩具不收拾好，下次就不好找。这些后果天然存在。\n📌【正面案例】：\n天气寒冷，孩子不戴手套 → 很快，手指冰凉，他会主动跑回来要戴上。孩子通过亲身体验，学会判断和调整，家长只需在一旁耐心观察、尊重孩子的选择。\n吃饭时间不好好吃饭 → 吃饭结束后，孩子可能会饿。下次他便更愿意好好吃饭。如果这时家长遵循“柔和而坚定”的原则，即便孩子饭点过后哭闹要吃，也温柔地安慰“我们需要等下顿吃饭时间再吃。” 这样，孩子逐渐明白了饭点的重要性。\n玩完玩具不收拾 → 下一次玩时，想找的玩具满屋乱翻很难找到。这时向孩子解释清楚“每次玩完后，收好玩具，下次就能更容易找到”，并在他需要时提供适度的帮助，孩子通常都乐意配合。\n❌【反面案例】：\n孩子不穿外套，家长强行给他穿上 → 不仅引发抗拒，还可能破坏亲子间的信任。此刻，孩子需要的是体验寒冷，而不是家长的粗暴干预。\n孩子不好好吃饭，被威胁“不让玩玩具”或“不准看动画片” → 这种做法让孩子无法理解“吃饭”和“玩具、动画片”之间的逻辑关系，割裂了行为与后果之间本该清晰自然的联系，剥夺了孩子学习因果的机会。\n打坏玩具，家长立刻买新的 → 孩子很快会认为弄坏东西没什么大不了。正确的做法是让孩子看到破损的结果，学习承担。比如可以一同尝试修理，让他理解“东西坏了就无法继续使用”，培养责任意识。\n🎈 【自然后果实施要点】：\n家长在面对自然后果时，切忌指责、羞辱或“事后诸葛亮”式的说教。不要说这类话“看吧，我早说过，我早就告诉过你”，不要在孩子本可以从生活里自然获得的教训上再添上一把火。孩子会通过体验，自己学会应对。\n父母应该温和地支持，比如说：“我相信你能想办法。” 当然，前提是后果必须安全。像在马路上玩耍，这类不可承受的后果，绝对不能放任发生。\n📚 看一个书中的例子：\n这个例子让我们看到，当父母决定让孩子体验自然后果时，自己同样要经历一次考验。因为孩子必须面对相应的结果，而父母要想坚持这样的教育方式，就必须足够坚定，不被一时的心软动摇。\n⚠️ 不适用自然后果的情形，以下情形中不能用自然后果方法，需要监护人及时保护和干预：\n孩子处于危险情境：如马路上玩耍、触碰电器。\n行为会伤害他人：例如乱丢石头、推搡同伴。\n后果不明显或延迟太久：比如不刷牙、吃太多糖、长时间不洗澡。\n2. 逻辑后果（Logical Consequences）： 逻辑后果，是由大人预设、在相互尊重的基础上设立的、与行为直接相关的结果。不同于自然后果那样自动发生，逻辑后果需要家长和孩子事先达成共识，且合情合理，帮助孩子理解行为背后的责任。\n📚 书中的一个例子：\n这个例子中，孩子喜欢玩牛奶杯，撒出来会弄脏地板。家长可以事先和他约定好：“如果洒了，就要自己擦干净，保持地面干净。” 孩子可能会忘，家长可以温和提醒：“你记得咱们说过的约定吗？”\n如果洒了，家长不发火、不批评，而是可以问：“需要我帮忙吗，需要帮你拿纸擦地吗？”这个过程不是惩罚，而是承担自然责任。孩子不会觉得是“被罚”，反而会把它视作解决问题的一种方式。更重要的是，下次他再玩，就会自然权衡后果。\n其中保持规则事先明确，结果合理，彼此尊重。这既教会孩子自律，也保护了他的小小自尊心。\n🌱 结语 这些方法，不仅在孩子成长过程中逐步建立起他内在的价值体系，也帮助父母管理自身的控制欲，避免滥用权威、以威胁和惩罚来解决问题，从而营造出一种温暖、平等、互相尊重的亲子关系。\n更重要的是，这样的养育方式，会在孩子步入青春期时，显著降低冲突和对抗的发生频率。青春期的逆反，多半源自三个核心原因：对权威的本能抗拒、缺乏自我控制的体验，以及自主意识的迅速觉醒。\n如果一个孩子从小生活在武断、惩罚式的管教环境中，习惯于被命令、被否定，他在青春期便极有可能以激烈对抗的方式，来争夺迟来的自主权。\n而相反，若孩子在成长过程中，逐渐习惯于通过自然后果与逻辑后果来面对问题，学会为自己的选择承担责任，学会平衡自由与规则，他的自律能力就会内化于心。到了青春期，他无需用叛逆的方式去证明自己，只需凭借已然形成的价值观和判断力，自主选择，自在成长。\n✨ 教育孩子，其实也是在教育那个还未被治愈的自己。当父母学会放下控制，孩子也会慢慢学会对自己负责。小时候你用爱与理解守护规则，长大后他便能用自律与担当守护自己。✨\n","link":"https://mengwoods.github.io/cn/post/wechat/2025/2025-04-01-teach-kid-penalty/","section":"post","tags":null,"title":"孩子越管越不听，试试这2个办法"},{"body":"什么是机会成本？ 在人生的每一次选择中，我们总是面临一个隐形的代价，那就是机会成本(opportunity cost)。这个经济学名词与我们的生活息息相关。简单来说，如果面对两个选项A与B，机会成本就是为了选择A而放弃掉的B所能带来的收益。\n换句话说，每一次选择都伴随着“错失的可能性”，而这种潜在的损失即为机会成本。\n生活上的一些例子 时间的代价 周末，你是选择睡到自然醒，还是早起跑步提升体能？或者，你可能会考虑加班赚取外快。\n如果选择休息，机会成本可能是锻炼身体带来的健康收益； 如果选择锻炼，机会成本则是放弃了额外的收入； 如果选择加班，你可能会牺牲和家人朋友共度的美好时光。 时间是不可再生的资源，而它的每一次使用都会涉及权衡。\n投资的选择 假设你手头有10万元存款：\n你可以选择将它存入银行，享受每年的固定利率； 也可以投资基金或股票，可能获得更高的年化收益（也伴随着风险）； 或者，你选择花掉这笔钱，购买一辆心仪的车。 如果你选择保守储蓄，机会成本就是未投资股票可能获得的高额回报；如果选择买车，机会成本则是这笔钱未来可能增值的潜力。\n贷款买房还是租房 贷款买房或租房是种常见的选择，都伴随着机会成本。\n贷款买房能带来稳定的居住条件和归属感，同时可能获得房产未来的增值。然而，其机会成本在于占用了大量资金用于首付和贷款偿还，失去了将这些资金投入其他高回报领域（如股票、基金）或用于提升生活品质的可能性。如果未来需要换城市生活或工作，房产的流动性相对较低，也可能成为一种束缚。\n租房提供更多的灵活性和资金自由。省下的首付或贷款金额可以投入到投资市场，或用于享受更高品质的生活。此外，租房便于随时搬迁，适合需要频繁更换居住地的人。然而，其机会成本在于没有资产积累的过程，长时间租住可能导致租金开支最终超过买房成本，并错过房产增值带来的长期收益。\n这些选择的关键在于你更重视哪方面的价值：是资产增值、生活质量，还是短期经济自由。\n面临选择时应该怎么思考？ 明确目标是减少付出机会成本的重要一步。只有清晰了解自己的核心追求，才能在选择中做出符合长远目标的决定。无论是追求财务自由还是家庭幸福，聚焦于最重要的事情能够让你减少迷茫和纠结。每次选择前，不妨问问自己，“这个决定是否对我的长期目标有帮助？”\n在资源规划上，保持灵活性至关重要。不要将所有资源集中投入到一个选项中，比如购房时避免让房贷占用家庭收入的过大比例。合理的分散能为你预留应对突发情况的空间，从而让未来有更多可能性。\n信息收集与分析能力是良好决策的基石。很多选择难以判断优劣，其根本原因是缺乏足够的信息。通过咨询有经验的人、广泛阅读背景资料，你可以为自己的决策提供更多依据。比如将每个选项的得失清晰地列出来，有助于更客观地进行权衡。\n最后，用长期眼光看待每一个选择。不要被短期利益迷惑，才能为未来创造更多价值。对身体健康、知识、技能的投资，短期内可能看不到回报，但它们的复利效应会在未来显现。选择那些越努力越幸运的方向，比如将宝贵的时间用来持续学习、提升身体素质或积累经验，这些都将成为未来的宝贵财富。\n人生每一步都值得珍惜 每个人的一生都像是一场旅行，在无数次选择中塑造自己的独特轨迹。或许你曾后悔过某些决定，但请记住，每一次选择都是通向未来的桥梁，只要确认好方向是所追求的，任何时候开始努力做一件事都不晚。\n机会成本虽然让我们放弃了一些可能性，但它也提醒我们，生命中最重要的是珍惜当下的决定，并为此全力以赴。\n愿你在每一次选择中，都能清晰看见自己的方向，并收获成长的喜悦。\n","link":"https://mengwoods.github.io/cn/post/wechat/2025/2025-01-10-oportunity-cost/","section":"post","tags":null,"title":"什么是机会成本"},{"body":"年底了，你的资本收入该如何报税给Vero？ 本文基于Vero网站信息总结以及数次电话咨询。如有遗漏欢迎补充。\n什么是资本收入？ 在芬兰，收入主要分为两类：就业收入和资本收入。\n就业收入主要指工资收入。这部分收入在申请税卡时已经填写完毕，通常无需频繁调整。\n资本收入则是通过持有资产获得的收益，包括租金收入、出售房产的收益、股息收入、利息收入、寿险收益以及基金利润。此外，还包括林业收入中的资本收入部分、企业收入中的资本收入部分以及合伙企业的收益。这些收入源自纳税人的投资行为，并按资本收入税率缴税。\n相比之下，资本收入的时间不固定。例如，出售资产产生的收益不一定在固定时间内发生，但这些收益都需要如实申报纳税。\n税率是多少？ 资本收入的征税是累进制的。基本税率为30%，资本收入超过30,000的部分，税率为34%。\n什么情况资本收入需要报税？ 持有股票、基金期间无需纳税，仅当出售时才需考虑报税。\n当您以盈利出售股票时，需按照资本利得税率对销售利润纳税。无论股票来自哪里，交易平台在哪，获利部分都需要报税。\n在计算利润时，可以从销售额中扣除持股的手续费、经纪费等。 如果出售股票产生损失，可以从资本收益中抵扣这些损失进行税务处理。 免税额：如果在一整年内出售的股票/基金总额不超过1,000欧元，那么无需为销售利润纳税。这1,000欧元的免税销售额涵盖了当年所有的销售额，而不只是个别股票的销售金额。然而，尽管在免税的范围内，仍需向Vero报告所获得利润。\n在国外银行或投资平台存款产生的利息都视为资本收益，并需要进行报税。国内银行会帮助处理这些税务信息，不需要自己报税。\n免税出售住宅，必须满足两个条件：首先，您需要至少拥有该房屋或公寓两年；其次，在这段时间内，您或您的家庭成员之一必须在该房屋或公寓中连续居住至少两年。家庭成员包括配偶和 18 岁以下的子女。若不满足这两点，出售时获得的利润需要征税。\n出租收入同样需要征税，需要进行报告，并且可以扣除与租赁相关的费用，如物业费、税费、维修费、装修成本、家电折旧费用、租金损失以及差旅费等。\n什么时候报税呢？ 第一种方法 如果在年中能够估算自己的资本销售情况，比如稳定的出租租金，那么你可以随时登录Vero的myTax网站来更新自己的税卡。在“Other income”中找到“Capital Income”，可以在这里填写具体的信息。如果在年中卖出股票，也可以使用这种方法来更新税卡中的资本受益信息。\n第二种方法 在年底，例如现在，可以提交额外的预付款申请，以补充今年的预付金额。对于2024年的税款，您可以在12月7日之后提交额外的预付款，并在明年1月底之前完成付款。这种方式可以避免补交税款并免除滞纳金和利息。\n在MyTax的税卡界面中，向下滑动到页面底部，会看到一个预付款申请按钮。这按钮允许您提交额外的预付款，以补充今年的预付金额。\n点击后，在“Other Income”下，可以添加资本收入获利信息。选择2024年的预付款，修改预付款金额，预估盈利额度，或者提交所有盈利和损失情况。Vero会根据这些信息进行计算，以确保您的预付款与实际税负相符。\n第三种方法 今年可以忽略报税，等到明年春季补缴，Vero会发送一封税款确认函。此时可以检查上面的信息是否正确。比如，投资平台如Nordnet会将信息告知Vero，但并非所有投资平台都会这样处理。此时可以检查税务明细中是否包含其他的资本收入。如果缺少信息，可以向Vero补充缺失的资本获利信息。提交申请后，Vero会进行评估，并邮寄账单，如果在一个月内支付额外的税务款项，则不需要支付延期付款利息。\n如果物理邮寄办理的话 如果通过物理邮寄办理，需要下载对应的表格并邮寄。填写纸质表格后，必须在年底之前送达Vero，以避免延期付款。\n公开交易的股票和证券需使用表格9A进行报税。\n出售房产、房产公司股份、非上市公司股份、以及加密资产时，应使用表格9进行报税。\n出售国外财产则需要使用16B表格进行报税。\n是提前预付好还是过后补缴好？ 当欠税被征时，延期利息最多可以减免20欧元。如果您提前增加预付税款，则没有任何额外费用。\n如果税款不超过650欧元的话，那么延期利息减免后这两种方法几乎没有什么差别。\n但如果超出650欧元，那么延期利息可能超过20欧元。这时，需要为超出的部分支付利息。\n可以访问vero王章了解更多，或者打电话咨询。\nhttps://www.vero.fi/en/businesses-and-corporations/taxes-and-charges/tax-prepayment/additional-prepayment/\n","link":"https://mengwoods.github.io/cn/post/wechat/2024/2024-12-10-report-captal-gain/","section":"post","tags":null,"title":"年底了，你的资本收入所得该如何报税给Vero？"},{"body":" 一个前提，如果你有条件在美国、欧洲等地投资，那么优先考虑这些地区的相关基金。\n在欧洲的投资者可以参考我的这几篇文章：\n这是欧洲最划算的标普500指数基金\n在芬兰定期投资一年标普500，收益如何？\n标普500适合投资吗？ 请参考我的这篇文章：标普500指数基金真的适合你吗？\n国内基金有什么异同？ 国外的标普500指数基金更多以ETF和共同基金的形式存在，费用率极低（与国内同类基金相差十倍以上），交易像股票般灵活，且复制指数的精度更高，误差极小，但投资者需自行承担税务处理等复杂性。\n在国内，追踪标普500指数的基金通常以QDII（合格境内机构投资者）形式存在，投资途径间接，管理费和汇率风险较高，同时受限于外汇额度，申购灵活性较弱。然而，它提供了以人民币参与全球化投资的便捷通道，并且都是追踪同样的美国标普500指数，仍然是优质的长期投资选择。\n还有的基金以QDII-FOF形式存在，是合格境内机构投资者-基金中的基金，是一种通过投资于其他海外基金（即基金中的基金）来间接进入海外资本市场的投资产品。\n国内基金的费率构成 管理费：这是QDII基金常见的收费项目，用于支付基金公司管理资产的费用。\n托管费：一些QDII基金还会收取托管费，主要用于支付基金资产的托管费用。\n申购、赎回费：部分基金可能收取一定比例的手续费，用于管理基金的流动性。申购费率一般较低，赎回费则随着持有时间的增加而逐渐减少。\n具体基金评比 首先，这些基金通常分为 A 类和 C 类两种，两者的主要区别在于收费方式：\nA 类份额：更适合长期投资者（投资时间超过一年），因为它的申购费用通常较低，而赎回费用随时间递减。 C 类份额：更适合短期投资者（投资时间少于一年），因其不收取申购费，但每日管理费稍高。 除收费差异外，A 类和 C 类份额在投资标的和运作上没有其他区别。以下评比主要针对 A 类基金，并仅涵盖目前在支付宝上可开放购买的基金产品。\n他们分别是：\n摩根标普500指数(QDII)人民币A(017641)\n博时标普500ETF联接A(050025)\n天弘标普500发起(QDII-FOF)A(007721)\n易方达标普500指数人民币A(161125)\n摩根标普500（017641）费用较低、限额低，适合小额投资者；\n博时标普500（050025）规模最大、历史最久，稳定性高；\n天弘标普500（007721）费用最低、限额高，灵活性强；\n易方达标普500（161125）费用最高、跟踪误差最低、晨星评级最高，长期表现优异。\n","link":"https://mengwoods.github.io/cn/post/wechat/2024/2024-12-06-sp500-in-alipay/cn/","section":"post","tags":null,"title":"我对比了支付宝上的几个标普500"},{"body":"为什么投资标普500？ 标普500指数涵盖了美国500家最具代表性的上市公司，横跨科技、金融、医疗、消费等多个行业，是衡量美国经济表现的“晴雨表”。从长期历史数据看，标普500的年化回报率稳居全球资本市场前列。\n过去30年，标普500指数的年总回报率平均为12.2%，这使其成为普通人甚至“什么都不懂”的投资者最适合的长期定投标的。这一回报率不仅超过绝大多数个人投资者的操作水平，也超越了全球大多数投资机构的表现。长期来看，标普500指数是经得起时间考验的财富增值工具。\n上图是代表中国股市的中国沪深300指数的历史数据。\n上图是代表欧洲股市的欧洲Stoxx600指数的历史数据。\n相较于中国或欧洲市场，美国企业不仅在盈利能力上遥遥领先，其全球化布局也更成熟。例如，苹果、微软、亚马逊等科技巨头，几乎是全球最聪明的大脑组成的企业集群。这些公司持续为世界创造巨大的价值，而投资标普500，就是间接投资这些全球最具创造力的公司。\n如果把这三个指数近十几年的表现放一起对比，是下图这样的，相信你能判断出哪个更适合长期投资：（S\u0026amp;P500：美国标普500，Stoxx Europe 600：欧洲600，CSI 300：中国沪深300）\n投资标普500是否存在收益风险？答案是肯定的。从历史曲线来看，标普500经历过多次显著的波动时期，例如2000年的互联网泡沫破裂、2008年的全球金融危机，以及2020年的新冠疫情冲击。这些波动的原因各不相同，持续时间也有长有短，但它们无一例外地对短期市场情绪造成了巨大影响。然而，如果拉长时间尺度，从几年甚至几十年的维度观察，你会发现标普500整体呈现出稳步增长的趋势。这也正是为什么标普500更适合长期投资，而非短期投机。通过坚持定投和持有，可以跨越短期波动的影响，享受市场长期增长带来的回报。\n投资策略是什么？ 投资标普500的核心策略只有一个——长期定投。虽然标普500指数历史上也经历了数次大幅下跌，但如果坚持定投，每逢下跌时期，同样的价格可以买到更多的市场份额，来平摊单价。以十年为周期，任何一次危机过后，标普500的表现都实现了新的高度。\n定投的核心原理在于用纪律性的投资方式对抗人性中的弱点。市场波动常常激发两种极端情绪：下跌时的恐慌和上涨时的贪婪，而这些情绪往往导致投资者追涨杀跌，错失良机。而定投通过定期、定额地投入资金，帮助投资者屏蔽外界噪音，不受短期市场信息的干扰。同时，定投还具有均摊成本的作用。在市场高点时，买入的资产较少；而在市场低点时，反而能以更低的价格买入更多资产，从而降低整体投资成本。对于需要长期持有的资产，定投是稳健且高效的策略，它不仅简化了投资决策，还能让你在长期中受益于市场的增长和复利效应。\n长期定投可以实现复利效应，而复利效应的结果是令人震撼的。下面是根据复利公式计算的定投收益表。\n以年化5%的回报率计算： 以年化10%的回报率计算： 如果是按照标普500指数过去三十年的平均年回报率12.2%计算：\n可以看到，投资一旦持续10年、20年乃至30年，你的财富收益会呈现显著的指数级增长——这就是时间和复利的威力。\n网上有很多复利计算器，可以自行查找并根据自己需要计算。上表中的收益没有考虑基金运行过程中的管理费用，需要自己根据实际情况计算。\n如果开始投资的话，你需要注意什么？ 投资的关键在于耐心，使用那些未来至少5年内不急需使用的钱进行长期投资，以五年、十年、二十年为单位进行投资。同时，面对市场的短期波动、外界信息干扰、短视频各种专家的分析、甚至平台下评论区的各种讨论，都需要有意识的屏蔽。对于长期投资者，这些冗余的信息都属于噪声。坚持自己设定的投资策略，不要被噪声轻易干扰。\n一旦设置好定投策略，就把这个账户“忘掉”，不要每天盯着涨跌。这些短期的波动对于长期收益毫无意义。你需要做的，只是根据自身的财务状况定期调整定投金额，确保每一笔资金都来自于“闲钱”。\n市场波动在所难免，不要投入太多精力去研究波动的具体原因和后续影响。把精力投入到生活的其他方面，比如锻炼身体、健康饮食或持续学习新技能。因为你活得越久，复利带给你的效果就会越明显，带来的收益也会越大。\n","link":"https://mengwoods.github.io/cn/post/wechat/2024/2024-12-06-should-you-buy-sp500/","section":"post","tags":null,"title":"标普500真的适合你吗？"},{"body":" 今年1月至9月，芬兰人被骗的损失高达2750万欧元，其中大部分损失来自钓鱼网站攻击，个人信息泄露是主要原因。\n我之前的这篇文章提过，在二手交易过程中，如果有人给你发送链接，那么几乎可以肯定对方是个骗子。\n这篇文章将结合我遇到的具体案例，分析骗子的诈骗的操作流程，看看他们是如何一步步盗取我们信息的。阅读本文，您将了解他们诈骗的基本步骤，掌握钓鱼网站的基本特征，从而避免上当受骗。\n故事开始 如果你在类似facebook发布二手产品时，可能会收到如下这类消息，他会先问你东西在不在，如果你说在的话：\nMatkahuolto是芬兰的一个快递运输公司，我们经常能看到他们的自提柜。所以他说使用这个运送是合理的。目前为止还都算正常。\n接下来有点不正常了：\n然后他让我去那个网站上确认信息：\n在我表示我的担忧后： 基本上，出现这种不正常的对话，就已经让人非常警惕了。我们接下来看看他发的网站。\n点开钓鱼网站 为了安全起见，我使用加密浏览器Tor打开了他发的网站，这样避免他追踪我的登录信息。\n（图中的两个黑块是我卖的东西的信息，我遮住了）不得不说，网站做得非常逼真，展示了买家的个人信息、地址以及支付的金额等。右下角还有一个人工服务按钮，点击后会弹出一个类似机器人聊天窗口！\n点击右侧收取货款按钮后，跳转到如下收款卡信息界面：\n即使到了这一步，填上信用卡卡号后，骗子获得卡号后也做不了什么。然而，在填写过程中，不知不觉中多出了一个格子，下图中我用红色圈了出来：\nCVV号的格子出现了，如果没有多加思考，很容易按照网站的指引下意识的填上。然而CVV号只有在我们付款时才会使用到。\n如果骗子同时掌握了卡号和CVV号，他们就能够轻松刷走信用卡上的钱，后果将不堪设想。\n这就是钓鱼网站整个运作的过程。由于网站是骗子自己控制的，你在上面填写的所有信息对于他们来说是完全透明的。\n如何识别钓鱼网站？ 我们需要注意的是**域名的解析过程是从右往左进行，而非从左往右。**例如，谷歌的部分域名包括 mail.google.com 和 maps.google.com，其中最右边的部分（即“.com”）是顶级域名，紧接着是“google.com”，表明这是谷歌官方注册的域名，而“mail”和“maps”只是谷歌内部的子域名，谷歌可以根据自己的服务定义任何子域名。\n来看看他这个网站域名：\n这个网站的域名 matkahuolto.transfer756.pics 中，“matkahuolto” 只是一个子域名，完全可以被任意修改为其他公司的名字，比如换成 posti： posti.transfer756.pics。其顶级域名是不常见的 “.pics”，二级域名为 transfer756，看起来可能是为了混淆当前服务的性质，如资金转账等。在该注册域名下，攻击者可以随意定义其子域名，但这些都与真正的 Matkahuolto 官方网站毫无关联。Matkahuolto 的官网域名是以 https://www.matkahuolto.fi/ 开始的。\n由于人们习惯从左向右解读域名，钓鱼网站利用这一心理，通过在子域名部分伪装成知名品牌名称，制造与官方网站之间的某种“关联”假象，从而误导用户信以为真。对于网址的末尾部分（顶级域名），如果不是常见的 .com、.fi、.cn 等，便需要提高警惕，因为不常见的顶级域名（如 .pics、.xyz 等）常被用来注册可疑或钓鱼网站。\n另外网站中包含随机数字是钓鱼网站的典型特征\n钓鱼网站常用随机码隐藏恶意意图，提升欺诈灵活性并延缓链接被屏蔽。这些随机路径不仅记录用户点击行为，帮助攻击者锁定目标，还通过复杂性绕过安全系统检测。这种手段延长了链接存活时间，增强了欺诈效果。\n","link":"https://mengwoods.github.io/cn/post/wechat/2024/2024-12-02-fraud/","section":"post","tags":null,"title":"Facebook上的骗子是如何盗取你银行卡信息的"},{"body":"前阵子，我曾分享过S银行的活期与定期存款账户，当时年利率的最高是2.8%。今天再一查，最高可达3%。不过，有几个细节需要注意，咱们一条条来说。\n自助就可以开通 在S银行官网，如下图所示，在网页操作界面直接找到相应的定期账户选项S-Määräaikaistili\n利率不是越久越高 不同于国内的定期存款“时间越长利率越高”的规律，S银行的定期利率可能还越久越低。开通前可以输入不同的月份数，计算利率。查询的利率每天都有可能变化，不是固定的。开通之后，存款期间利率保持不变。\n今天查到的利率如下：\n1个月3.0006% 2个月2.9644% 3：2.9313% 4：2.8516% 5：2.7720% 6：2.6924% 12：2.4610% 24：1.5550% 别用短期可能用到的钱 资金一旦存入定期账户，在期限到期前是无法轻松取出的。如果你需要提前终止存款合约，需要支付一定的手续费。下图是其官方文档说明，最少需要支付50欧元。。\n相比之下，如果你用的是Nordea银行，我推荐你了解一下他们的FlexiDeposit账户。这种账户的利率与S银行类似，但更加灵活——你可以随时取款，而无需支付额外费用。如果你感兴趣，可以参考我之前的文章介绍。\n","link":"https://mengwoods.github.io/cn/post/wechat/2024/2024-11-30-sbank-term/","section":"post","tags":null,"title":"S-Pankki定期利率来到了3%，你需要了解的一些事情"},{"body":" 本文列出了一些具体原因，说明为何应尽早为孩子开通一个账户，供您参考。最后，针对在芬兰生活的家庭提出相关建议。\n免税地将资金持续赠与孩子 孩子成长的过程中，总有许多阶段需要经济支持：学习新技能、购买首套住房或汽车、旅行、追求兴趣爱好等等。然而，在大多数国家，直接赠与大额资金往往会面临赠与税的负担。例如在芬兰，三年内累计赠与金额达到或超过5000欧元就需要缴纳赠与税。\n但如果从孩子出生时便开设一个账户，父母可按照赠与税免税额度合理规划每月转账金额。例如在芬兰，单个父母每月可以转账约138欧元，两位父母共同赠与则可达到每个月277欧元。\n若从孩子出生开始到18岁坚持这一计划，本金将累积至约59832欧元。这笔资金对于刚步入社会的年轻人，无疑是一笔不小的财富，能够为他们提供学习深造、创业或生活规划的强大支持。\n如果父母愿意的话，18岁之后还可以坚持这种赠与，这种规划不仅能让孩子早日受益，还能有效减少未来遗产税的负担。与其将财产留作遗产在晚年一次性赠与（此时孩子已经接近退休年龄），不如尽早赠与，让孩子在其人生发展的黄金阶段尽可能地利用这些资源，助力他们实现梦想。\n时间可以产生复利效果 将资金存入账户，哪怕是最基础的活期存款，也能获得约0.5%-1%的利息收益。如果选择一些储蓄账户或定期存款，目前的年利率可以达到3%左右。而稳健型投资如国家政府债券，其利率通常在3%-6%之间，既安全又能获得相对较高的回报。此外，若选择定投指数基金（例如标普500指数基金），年化收益率更有望达到10%左右。\n假设每月定投277元，持续18年，本金将累积至59832元。通过复利的力量，不同利率条件下的收益差异显著，下表将直观展示各利率水平下按月度复利所带来的利息收益及最终总额。\n利率越高，收益潜力越大，您可以根据自身的风险承受能力选择适合的理财产品。\n如果您对股票感兴趣且具备一定研究能力，还可以开通股票账户，投资于如美国股市这样的成熟市场。尽管风险较高，但潜在回报也更为可观。假如18年前投资1000元购买亚马逊的股票，那么如今这些股票的价值已增长至约10万元。\n培养孩子的财商 当孩子达到可以独立使用借记卡的年龄（通常至少6岁），可以为他们申请一张借记卡。这不仅让孩子能够独立管理自己的开销，还可以通过定期给予一定额度的零花钱，帮助他们逐步建立对金钱的基本认知和责任感。\n在孩子成年后，将账户的支配权正式移交给他们，让他们直接体验复利和投资的力量。这种实践能够深刻影响孩子的财务观念，帮助他们在未来更有信心地进行投资规划和财务管理，为自己的生活奠定坚实的基础。\n储蓄带来的“安全感” 储蓄能够为人带来强大的安全感。不仅能为孩子的成长提供保障，也能让父母更加安心，生活中，我们可能并不需要花费太多钱，但如果完全没有储蓄，那种不确定性会让人感到不安。这种缺乏安全感的状态会导致我们在面对人生抉择时裹足不前，不敢冒险、不敢尝试，从而错失许多宝贵的成长和选择机会。即使孩子并未直接使用这些钱，单单将其保存在账面上，也能为他带来极大的安全感，为他的选择提供强大的支持与底气。\n在芬兰，如何为孩子开通账户 几乎所有银行都提供为孩子开设账户的服务，而且在26岁之前没有月基本费用。家长可以选择在线或线下申请开户。开通账户后，可以与银行工作人员咨询适合孩子的理财项目。只要孩子拥有身份号和姓名，就可以为其申请账户，各个银行都非常乐意为孩子开设账户。开通账户后，在孩子成年之前，父母拥有对账户的控制权。\n如果您对投资感兴趣且具备一定的动手能力，也可以选择通过券商为孩子开设账户。例如，Nordnet可以在线为孩子开户，家长可以操作孩子的账户进行投资或定投。如果投资股票的话，还可以开通OST账户，推迟股息和买卖交易中的资本收益税，直到未来取出的时候才需要报税。相比银行，券商提供的相关产品手续费低很多，而且选择范围更广。不过，需要注意的是，只有支持芬兰电子身份认证的券商才可以为孩子开设账户，因此一些国际券商无法提供此类服务。\n","link":"https://mengwoods.github.io/cn/post/wechat/2024/2024-12-08-account-for-kid/","section":"post","tags":null,"title":"为什么你需要尽早给孩子开通账户？"},{"body":"ASP是什么？ ASP账户，全称“住房储蓄账户”(asuntosäästöpalkkio)，是基于《购房储蓄奖励法》设立的一项政策，一种专为首次购房者设计的独特储蓄工具。这一系统由芬兰国家财政部提供指导并确保其顺利实施。\n首次存款需在15岁至44岁之间完成，每个季度存入150-4500欧元，并且至少存8个季度(中间可以间断)。当储蓄达到目标房屋价格的10%时，可以申请ASP贷款用于购房，由政府担保。\n账户的主要优势 开立ASP账户后，可以享受以下的免税利息收益：\n每年1%的基础存款利息（每年底结算发放）。 在开户的当年以及接下来的五年享有高达4%的奖励利息（最终贷款购房时结算并发放）。 贷款前10年内，若利率超过3.8%，超出部分的70%由国家支付。国家财政署每年分两次（5月31日和11月30日）向银行支付补贴金额。若贷款利率低于3.8%，借款人需全额支付利息。\nASP贷款利率低于普通首套房贷款利率，房贷利率一般由12月的Eurobor基准利率加银行边际利率构成。相比普通贷款，ASP贷款的边际利率略低，但需与银行具体协商确定。\n使用ASP的条件是什么？ 为了符合申请ASP贷款的资格，需要：\n首次存款需在15岁至44岁之间完成。 之前未拥有过50%或以上房产的人。 在至少8个日历季度内向账户存入资金。 每个季度的存款金额需在150至4500欧元之间。这意味着，通常情况下，至少需要储蓄两年才能满足贷款申请的基本要求。 存款无需连续完成，储户可以根据需要暂停存款。 不同地区最多的贷款额度 但ASP贷款是有额度上限的，不同地区的上限金额见下图。一般来说，实际房价往往会高于这个限额，对于超出部分，购房者需要用个人资金补充，或者与银行商议额外的贷款来弥补差额。\n如果你有计划地在两年内存入对应地区上限金额的10%，可以在满足ASP贷款要求的同时，不会存入过多的钱。这种方式可以合理规划存款，以最大化利用ASP贷款的上限额度。\n换算成每个月的话，赫尔辛基地区每个月可以存入958.33欧元，埃斯波、万塔和考尼安地区为770.83欧元，坦佩雷和土尔库为666.67欧元，其他地区为583.33欧元。\n其他问题 中途可以关闭账户吗？ 可以，但在这种情况下，您账户中已支付的存款利息将被征收30%的源泉税。此外，额外的4%何奖励利息也没有了。所以该账户只适合用于购房，不适合储蓄投资。\n如何开通呢？ 所有的芬兰银行都支持开通ASP，可以自行联系银行开通办理。\n可以转换银行吗？ 在储蓄期间，ASP账户可以从一家银行转移到另一家银行。转移过程中，储蓄不会中断，且账户历史将完整转移至接收银行。在购房合同签订之前，账户转移必须完成。新银行将继续为账户提供服务，并负责支付储蓄的利息。\nASP账户中超出上限的金额如何处理？ 如果储户ASP账户中的储蓄超过房产购置所需的10%，可以与银行协商如何处理超出部分。根据税务部门规定，即使存款未完全用于购房，ASP账户中支付的利息仍然免税。\n可以从ASP账户中取钱吗？ 从账户中提取资金，ASP协议将终止。储户可以停止存款并将储蓄用于其他目的，但此时将无法享受税收优惠利息。如果仍符合年龄条件且购房需求依然存在，储户可以重新开立ASP账户，并从头开始储蓄。\n在国外有房产还可以开通ASP吗？ 不可以。\n购买的房子可以出租吗？ 购买后，房屋必须作为永久居所进行个人使用。可以租赁最长两年，租赁房屋需要特殊情况的证明，例如出国学习或工作，或在其他地点工作。军事服役也被视为特殊情况。对于长期租赁，ASP贷款必须转换为普通抵押贷款。必须与银行达成此协议。\n可以两个ASP账户共同购买一套房子吗？ 两名拥有独立ASP账户的储户可以联合购置一套房屋。在满足ASP贷款条件之前，双方需分别在各自账户中储蓄。联合购房时，可以选择申请一笔共享贷款或各自单独贷款。\n其他 ASP制度的目的是鼓励储蓄，为首套自住住房的购置提供更多的机会。购买使用ASP贷款的房屋必须由借款人永久居住，即购买后必须用于自己作为主要居住地使用。房屋可以在特殊情况下（如学习、工作等）租赁最长两年，但超过两年的租赁是不允许的。国家财政部监控ASP贷款的使用情况，如果发现资金被用于法律规定之外的用途，可能会终止利率补贴，并要求借款人返还获得的补贴，最多五倍的金额。提供ASP贷款的金融机构也有法定义务，每月向国家财政部提交有关ASP贷款的相关数据，以确保贷款的合规使用。若未能履行这些义务，国家财政部可以对金融机构实施罚款或设定期限要求其完成电子数据传输。\n总结 我认为ASP账户有两个显著的优点。首先，国家提供担保，确保您可以获得一部分贷款，使您能够通过银行获得额外资金，顺利购买理想的房产。这样一来，您就不必担心因资金不足或银行贷款额度受限而无法实现购房目标，这无疑是其最主要的优势。其次，国家对于超过3.8%利率部分提供利息补贴，尽管大多数情况下利率不会超过这个限度，但也是一个附加优势。\n参考链接： https://www.valtiokonttori.fi/en/services/financing-and-loans/asp-saving-and-asp-loans/#asp-saving\n","link":"https://mengwoods.github.io/cn/post/wechat/2024/2024-11-29-asp/","section":"post","tags":null,"title":"在芬兰计划买房，有必要开通ASP账户吗？"},{"body":"纳斯达克100 纳斯达克100指数作为美国重要的股市指标之一，与标普500相比有着显著的差异。标普500以覆盖范围广而著称，其成分股横跨各大行业，具有较高的稳定性和分散性。而纳斯达克100则以科技股为核心，其成分股多集中于高科技、通信和创新型企业。因此，从本质上看，标普500更像是经济全貌的晴雨表，而纳斯达克100则更像是技术革新与成长型企业的风向标。\n近年来，人工智能、云计算、自动驾驶、区块链等前沿技术领域的蓬勃发展，为科技股注入了强劲的上涨动力。特别是在疫情期间，远程办公、电子商务和在线娱乐需求激增，纳斯达克100的涨幅更是表现惊人，一度超越了标普500的整体表现。然而，需要注意的是，科技股的高增长背后也伴随着高波动性。纳斯达克100的指数走势对行业风口的依赖程度较大，一旦市场情绪转变或科技板块整体表现下滑，回调的可能性也会显著增加。\n风险 历史数据中，纳斯达克100曾经历过几次较为剧烈的下跌。例如，在2000年互联网泡沫破裂期间，该指数大幅下挫，跌幅远超标普500。同样，在2008年的金融危机中，其表现也相对更加脆弱。因此，投资者在选择纳斯达克100时需要具备较强的风险承受能力。虽然高回报吸引人，但潜在风险也不可忽视。\n从投资角度来看，纳斯达克100适合对科技领域有深刻理解，且愿意承担短期波动的投资者。合理的理财规划和资产配置非常关键。可以通过分散投资降低风险，比如将资金部分配置在较为稳健的标普500指数或债券资产上，以对冲科技股可能带来的波动。同时，关注市场动态、行业发展趋势，适时调整投资策略，也是管理风险的重要手段。\n基金横评 以下是我整理出的目前在支付宝平台上仍可开放购买的纳斯达克100指数基金清单，供您参考。这些基金为希望使用人民币投资的理财人士提供了便捷的渠道，是接触美股市场、特别是纳斯达克100指数的一种可行方式。\n投资者应重点关注以下指标：成本类指标（如买入费率、管理费和托管费）直接影响投资收益，建议优先选择费率较低的基金；年化跟踪误差衡量基金表现与指数的接近程度，误差越小越稳定，适合长期投资；基金规模关系到基金运作的稳定性和风险分散性，规模较大的基金通常更可靠；卖出免费时间决定资金的灵活性，短期投资者更适合流动性高的基金，对于长期持有的投资者，不需要关注这点。\n从上表中的费率和每日限额来看，我认为嘉实的优势较为明显。\n","link":"https://mengwoods.github.io/cn/post/wechat/2025/2025-01-07-alipay-nasdaq/","section":"post","tags":null,"title":"横评支付宝上的纳斯达克指数基金"},{"body":"如果你生活在欧元区，那么你一定听说过一个名词——Euribor。它是我们日常生活中一个无形但重要的存在，从存款、信用卡还款到房贷，许多金融活动都与它息息相关。那么，本文将带你了解Euribor究竟是什么，以及它如何具体影响我们的生活。\n什么是Euribor？ Euribor（Euro Interbank Offered Rate），中文翻译为欧洲银行间同业拆借利率，是欧洲银行间市场上，银行之间相互借钱时使用的基准利率。简单来说，它是银行用来计算贷款成本的“批发价格”。\n银行在日常运营中可能会面临短期的资金缺口，比如客户提现、贷款发放或其他资金需求。为了满足这些临时需求，银行会向其他银行借钱，而这类借款通常是短期的，期限从一天到一年不等。Euribor正是用来确定这些短期借款的利率。\n每天上午，欧洲的主要银行会提交它们认为可以接受的借贷利率，这些银行包括欧洲的大型商业银行如德意志银行、荷兰银行、芬兰OP银行等16家主要银行。所有利率数据都会提交给欧洲货币市场协会（EMMI, European Money Markets Institute），由EMMI负责计算并公布Euribor。\n最终的Euribor是剔除了最高和最低报价后取平均值得出的。这一利率分为多个期限，比如1周、1个月、3个月、6个月和12个月，分别对应不同时间长度的借款利率。\nEuribor数据被广泛用于银行贷款、储蓄产品和金融合同的定价。如果你想查看最新的Euribor数据，可以访问欧洲货币市场协会（EMMI）官网，也可以通过各大财经网站或银行的官方渠道查询。\nEuribor的由来 1999年欧元诞生之时，欧洲各国需要一个统一的利率标准，以促进跨国银行业务和金融市场的流通。于是，巴黎的PIBOR、法兰克福的FIBOR 以及赫尔辛基的Helibor等国内参考利率合并为Euribor。作为欧元区货币市场的基准利率，它成为银行贷款、公司融资和金融产品定价的参照。\n但Euribor并不是孤立存在的。它的波动往往与欧洲央行的货币政策密切相关。当欧洲央行提高或降低基准利率时，Euribor也会随之调整。\nEuribor对普通人的影响 贷款：利率变化 假如你买了一套房子，申请了一笔房贷，大多数情况下，你的贷款利率是由Euribor加上银行加成（例如1%-2%）组成的。比如：\nEuribor为0%，银行加成为1%，你的房贷利率就是1%。 Euribor上涨到3%，银行加成不变，你的房贷利率则变为4%。 房贷利率高低，直接影响你每个月的还款金额。如果贷款30万欧元，期限20年：\n利率1%时，每月还款约为1382欧元； 利率4%时，每月还款增加到1818欧元。 对于普通家庭来说，这种差异足以影响生活质量。\n储蓄：利息变化 如果是储户，低Euribor时期，银行给出的存款利率也会非常低，甚至接近零。这意味着，你存在银行的钱几乎没有利息收益。\n投资：波动变化 Euribor还影响着其他金融产品的收益，比如债券、基金甚至养老金计划。当Euribor上升时，投资收益可能增加，但也伴随着更大的市场波动。\n影响Euribor的因素 Euribor波动的主要因素包括：\n欧洲央行的货币政策：当央行为抑制通货膨胀加息时，Euribor会随之上升；而当央行为刺激经济降息时，Euribor会下降。 市场资金流动性：当银行间资金紧缺时，Euribor可能迅速飙升。 经济前景和信心：如果市场对未来经济增长抱有信心，Euribor往往会上扬。 央行加息的原因与影响 近年来，欧洲央行频繁加息，主要原因是应对持续增高的通货膨胀。近年来，疫情、战争等原因导致了全球供应链受阻、能源价格飙升等一系列问题，最终推高商品价格导致通货膨胀。\n通过提高利率，央行希望达到以下效果：\n减少市场货币供应：借贷成本上升，企业和消费者的借贷意愿降低，市场中的货币流通量减少。 降低需求：贷款成本的增加使得消费者减少支出，企业放缓扩张步伐，从而降低整体需求，遏制物价进一步上涨。 加息会带来后果：\n抑制通胀：加息使得贷款成本增加，企业和消费者的支出减少，需求降低，价格上涨的速度可能因此放缓。 经济增速放缓：借贷成本上升会减少企业投资和消费者支出，可能导致经济增长减缓甚至陷入衰退。 金融市场波动：加息可能导致股票市场承压，同时债券收益率上升，对投资者资产配置产生影响。 欧洲央行提高基准利率后，银行间借贷成本直接上升，Euribor随之上涨。\n普通人该如何应对？ 面对Euribor的波动，普通人可以做什么？\n贷款者：选择合适的利率类型\n如果你喜欢稳定，可以选择固定利率贷款； 如果你对市场敏感，可以选择浮动利率贷款，但要预留足够的预算应对利率上涨。 储蓄者：多样化投资\n在低利率环境下，可以考虑债券、基金或其他金融工具，寻找更高的收益。 消费者：理性规划支出\n当贷款成本增加或市场波动时，合理调整家庭预算，减少非必要开支。 未来的展望 当前高通胀的背景下，加息和高Euribor可能会持续一段时间。不过如果未来，全球区域冲突若能够进一步稳定，那么能源价格、全球供应链将逐步恢复正常，通货膨胀和加息步伐或将减缓。\n一旦通胀得到控制，欧洲央行可能会逐步降低基准利率，以支持经济增长和就业恢复。这将进一步传导到Euribor的下降，贷款成本随之减少，生活成本压力有所缓解。\n","link":"https://mengwoods.github.io/cn/post/wechat/2025/2025-01-05-what-is-eurobor/","section":"post","tags":null,"title":"生活在欧元区，必须要了解的 Euribor"},{"body":"欧洲最划算的S\u0026amp;P500指数基金 欧洲的VOO\n引言 标普500指数，作为美国股市的风向标，囊括了500家市值最大、最具代表性的上市公司，是全球经济的重要晴雨表之一。通过投资标普500指数基金，投资者可以以极低成本覆盖美国市场，分享经济增长带来的红利。长期来看，其表现超过大多数主动管理型基金，是全球投资者进行资产配置的首选之一。\n在众多标普500指数基金中，VOO（Vanguard S\u0026amp;P 500 ETF）是最知名的产品之一。凭借超 5000亿美元 的资产管理规模和仅 0.03% 的超低管理费用，VOO 成为全球投资者眼中的“性价比之王”。然而，由于美国税收政策和欧洲统一基金市场规则（UCITS）的限制，VOO 无法在欧洲市场购买。\n欧洲的相关基金 在欧洲市场，iShares Core S\u0026amp;P 500 UCITS ETF USD (Acc) 是目前最受欢迎的标普500基金，资产规模达到991.55亿欧元，年管理费用（TER）为0.07%。该基金于2010年3月成立，注册地为爱尔兰，是欧洲市场规模最大且广泛投资者群体的标普500基金。\n如果按照管理费用升序排列，发现欧洲市场上也有一些管理费用仅为**0.03%**的基金，例如SPDR S\u0026amp;P 500 UCITS ETF (Acc)和SPDR S\u0026amp;P 500 UCITS ETF (Dist)。\n其中，SPDR S\u0026amp;P 500 UCITS ETF (Acc)于2023年10月成立，成立时间很短，目前规模为60亿欧元；而SPDR S\u0026amp;P 500 UCITS ETF (Dist)则成立于2010年5月，规模为990亿欧元。\n对于倾向于分红的投资者，选择SPDR S\u0026amp;P 500 UCITS ETF (Dist)是一个理想的选项。其资金规模也比较大，不需要担心流动性的问题。\n如果更偏向于长期投资，SPDR S\u0026amp;P 500 UCITS ETF (Acc)尽管目前规模相对前者较小，但在相关类别基金中也处于中上等水平，并且它呈现出持续增长的趋势。由于较低的管理费，具有很强的发展潜力，这支基金有望吸引越来越多的投资者参与。\n上述这些基金都是采用“完全复制策略”，直接投资标普500指数的成分股，可以确保对指数的高度精准跟踪。\n平台选择 在选择投资平台时，我尝试了几种不同的选项，以SPDR S\u0026amp;P 500 UCITS ETF (Acc)为例进行对比：\nNordnet平台支持购买该基金，但它不在自动定投可选基金列表中，用户只能进行单次购买。而且每次购买时需要支付较高的手续，约15欧元左右。\nTrading212平台支持购买该基金，提供自动定投功能且不收取手续费，不过涉及到外币交易会收取0.15%的货币转换费。\nTrade Republic每笔交易收取1欧元手续费，但该平台提供免手续费用的自动定投服务，没有货币转换费。\n基于以上来看，如果想长期定投这支基金的话，三者中Trade Republic最划算，同时Trading212也不错。如果你有其他的平台推荐，欢迎评论区留言！\n","link":"https://mengwoods.github.io/cn/post/wechat/2024/2024-11-24-cheapest-etf-in-europe/","section":"post","tags":null,"title":"欧洲最划算的标普500指数基金"},{"body":"面对人生的种种不确定性，我们该怎么做？|《一如既往》 分享和解读一本很有启发性的书《一如既往》\n引言 亚马逊公司创始人贝佐斯曾说，人们经常问他未来10年会发生哪些变化。​“但是几乎没有人问过我：‘未来10年里有什么事情不会改变？’我认为，这才是更重要的问题。​”亚马逊的策略和规划，都会基于未来不会改变的事情，比如人们对物美价廉的需求。\n当今世界瞬息万变，人们都渴望能够预测未来，远离一切不确定性，但这本书却告诉我们：与其费尽心思预测未来的变化，还不如关注永恒不变的人性。面对变化，我们应该学会寻找到那些永恒的真理和不变的规律，以便在动荡中立稳脚跟。\n无论穿越到500年前还是500年后，你都会发现：人们一如既往地深陷贪婪和恐惧之中难以自拔。人们一如既往地被风险、嫉妒、种族认同等问题困扰。人们一如既往地高傲自大、目光短浅。人们一如既往地追寻幸福生活的秘诀，以及根本不存在的确定性。人类的行为一如既往，从未改变。\n接下来，根据书中有关不确定性的话题，解读书中提到的几条原则。\n未来是无法预测的 1933年2月15日，美国当选总统富兰克林·罗斯福正与民众交流。然而，隐在人群中的一名砌砖工赞加拉试图枪杀罗斯福。混乱中他开了五枪，其中一枪击中了芝加哥市长安东·瑟马克，导致其不幸身亡。而罗斯福则毫发无伤，顺利于两周后宣誓就职。如果赞加拉成功，接替罗斯福的将是副总统候选人加纳。加纳坚决反对罗斯福后来的“新政”。\n如果枪击成功，这些政策可能就从未实施过。但罗斯福新政积极地缓解了1929年美国大萧条的影响，重塑了美国政府与市场之间的关系。虽然其成效在当时备受争议，但许多政策奠定了现代福利国家的基础。社会保障制度、银行存款保险和金融监管等成果至今仍在影响着美国经济与社会结构。一次偏离的子弹就可以改变一个国家的命运。\n假如今年特朗普在宾夕法尼亚州集会演讲时被成功击杀，则必定会对未来几年美国以及全球政治格局带来巨大的不确定性。一个直接的已经显现的影响是对当前胶着的俄乌战争。\n类似的事件在历史上屡见不鲜，一个看似微不足道的小细节，就足以让原本的发展轨迹朝着截然不同的方向演变。每一件事情的背后都隐藏着无比复杂的因果链条，事物的发展总是充满了不可预测性。\n这提醒我们，**不要过于依赖和迷信于对未来的预测，未来从来不是简单趋势的延续，**我们无法完全洞悉事件之间的千丝万缕的联系。同时，我们也要保持开放的心态，敢于想象——无论今天的世界看起来多么稳定多么熟悉，到了明天，一切都可能发生翻天覆地的变化，甚至变为一个完全陌生的世界。\n真正的风险来自意外 2001年9月11日早晨，在恐怖分子对纽约世界贸易中心发动袭击前的几分钟，当地某广播电视台开始播报：​“早上好！现在是早上8点，温度为18摄氏度。今天是9月11日，星期二……今天是美好的一天，阳光明媚，天气怡人……”但是，没人能够预料到接下来发生了什么……\n所谓风险，就是你认为已经考虑周全，而实际被遗漏的东西。\n911恐怖袭击、突发的疫情、局部的战争冲突等等，他们都是影响世界的重大事件，然而在他们发生之前，几乎没有任何人能够预判到。往往这种无人知晓的意外会带来严重的风险，如果知道最大的风险是什么，就一定会加强防范；加强防范，风险自然就会降低。但人们无法防范未知的风险，正因如此，意外可能在任何时刻发生，永远无法被人类控制，人类对这个世界的认知太有限了。\n你无法为没有预想到的事情做好准备。你越觉得自己考虑得周全，当意外发生时，你所遭受的冲击就越大。\n面对未知，我们能做什么？\n第一，面对可预见的风险，尽管我们无法准确预测风险何时何地会发生，但仍需做好风险终将到来的准备。这意味着要为最坏的情况做打算，做好准备工作比精确预测更为重要。\n第二，接受这个现实，未知风险是不可预测的。**无论我们准备得多么周全，都要为突发情况留出足够的余地。**例如，在评估债务承担能力时，实际能承受的额度通常比预期的要少。因此，准备工作必须有弹性，以应对无法预见的风险。\n稳定中蕴藏危机 在20世纪60年代，科技飞速发展，经济学家也力图消除经济衰退的因素。然而，经济学家海曼·明斯基提出了一个开创性的理论——“金融不稳定假说”，认为完全消除经济衰退是无法实现的。明斯基的理论没有复杂的数学公式，而是基于对人类心理过程的观察。他认为，当经济稳定时，人们往往变得过于乐观，并因此增加负债。然而，这种乐观情绪和负债的增加反而会使经济变得不稳定。因此，明斯基的核心观点是：稳定本身是一种不稳定的状态。\n在物理学中，运动与静止的关系是这样的：运动是永恒的，静止是相对的。我认为这二者有一定的相似性：不稳定是永恒的，所谓的稳定，不过是在不稳定状态中截取的短暂片段而已。\n21世纪以来，人类在医学和疫情防御方面取得了显著进步，人们曾在过去五十年内从未经历过大范围的疫情。这种长期的稳定让人们习以为常，逐渐放松了警惕。然而，新冠疫情的突然爆发让所有人措手不及。过去的美好和稳定时光掩盖了潜在的威胁，使人们忽视了流行病学家多年来的警告。许多人甚至认为传染病只是历史故事，与现代社会无关。当风险真正降临时，这种自满和松懈让世界付出了巨大的代价。正如美国国家卫生官员协会首席执行官洛里·弗里曼所说：“公共卫生的成功反而让它成了预算削减的目标。”\n在稳定中，人们应警惕过度乐观，保持清晰的风险意识，认识到稳定并不等于安全。避免因表面的平静而掉以轻心。同时，也不要对不稳定过度恐惧，因为不稳定并不意味着崩溃。\n微小的变化日积月累会带来巨变 大多数灾难来自一系列微小的风险，它们小到容易被人们忽略，最终却酿成大祸。同理，大多数伟大的成就也来自一些微不足道的小事，它们不断叠加，创造了意想不到的成果。\n耶鲁大学曾进行过一项研究，发现肥胖人群的主要原因并非正餐过量，而是每天吃太多零食。类似地，许多看似不起眼的日常习惯在不断积累后，往往带来巨大影响。例如，现代人普遍感到时间不够用，常常熬夜才能完成计划，但却在不经意间被短视频等琐碎事情占据，最终消耗了大量时间。\n相反，技能和才能的提升是通过一点一滴的积累实现的，比如定期锻炼、健康饮食和持续学习。虽然在短期内看不到显著效果，但只要能够长期坚持下去，最终的结果必定是惊人的。这种复利效应也是大自然蓬勃发展的核心原因之一。进化本身就是复利效应的体现，从单细胞生物到丰富多样的物种，地球上的生命经历了漫长的演变。而人类也在不断积累与发展中，站在前人的肩膀上，创造出如今的强大科学技术。\n物理学家艾伯特·巴特利特说过：​“人类最大的弱点就是无法理解指数函数。​”\n在电影《肖申克的救赎》中，主人公原本是一个银行家，深知复利效应的力量。正是凭借对微小行动的坚持，利用一个不起眼的雕刻小锤，经过几十年的日积月累，最终挖出了一个巨大的通道，成功逃脱。奇迹的发生靠的就是持久的日积月累。\n然而，尽管这一原理看似简单，能够坚持长期行动的人却寥寥无几。就像投资一样，大多数人更关注如何迅速获得回报，如何避免任何损失。因为复利效应实际上是在与人性中深藏的贪婪、恐惧和急功近利的心理作斗争，这些本能深深地刻在我们基因里。\n取得进步，需要同时乐观与悲观 最佳的理财计划是悲观地储蓄，乐观地投资。既相信明天会更好，又能认识到现实世界充满挫折、失落、意外与动荡。乐观地梦想，悲观的计划。\n比尔·盖茨在19岁时辍学创业，立志让每个家庭和办公桌上都有一台计算机，他对自己能力的高度的乐观和自信。微软的联合创始人保罗·艾伦描述盖茨时提到，他聪明、好胜且执着。然而，盖茨也展现出另一面偏执的特质，他始终坚持在公司账上保留足够现金，确保没有营业收入的情况下能维持12个月的运营。盖茨曾表示，科技快速变化，任何公司都无法预测下一年是否有收入，自己的悲观看法反而帮助他维持了公司的稳定，这也成为他长期乐观主义的基础。\n盖茨似乎明白一个道理：只有足够悲观，才能维系眼前的生存，才有机会成为长期的乐观主义者。\n总结 在这个充满不确定性的世界里，我们无法预见每一次变化，也无法控制所有的风险。然而，正如本书所揭示的，**真正的智慧在于理解人性的恒常，意识到不确定性始终存在。**而我们能做的，就是在这不断变化的环境中保持韧性。通过微小的积累与耐心、保持充分的准备，以及在乐观与悲观之间找到平衡，我们能够在动荡中稳步前行。未来依然充满挑战，只有深刻理解并适应这些人生中的不确定性，我们才能真正具备在复杂世界中生存与发展的能力，迎接每一个新机遇。\n","link":"https://mengwoods.github.io/cn/post/wechat/2024/2024-11-20-same-as-ever/","section":"post","tags":null,"title":"面对人生的种种不确定性，我们该怎么做？|《一如既往》"},{"body":"强化学习理论基础\n背景 强化学习（Reinforcement Learning, RL）是机器学习中一个强大且快速发展的分支，受行为心理学的启发。它主要研究智能体如何在环境中采取行动，以最大化某种累积奖励的概念。与监督学习不同，监督学习中的学习智能体是给定输入-输出对，而强化学习则强调通过交互进行学习。\n强化学习（RL）在各种领域的应用至关重要。在机器人技术中，它驱动自主导航和物体操作任务；在游戏领域，如AlphaGo展示了其在战略决策方面的卓越能力。RL优化金融交易策略，调整医疗保健治疗方案，并增强自然语言处理和计算机视觉的能力。其应用范围还扩展到智能电网、推荐系统和虚拟助理等领域，凸显了RL在各个领域中的变革性影响。\n理论基础 强化学习（RL）问题旨在通过与环境 $\\mathcal{E}$ 的交互，在多个离散时间步中实现学习以达到某个目标。在每个时间步 $t$，智能体接收环境状态空间 $\\mathcal{S}$ 中的一个状态 ${s}{t}$，并根据策略 $\\pi({a}{t}|{s}{t})$ 选择一个动作 $a_t \\in \\mathcal {A}(s_t)$，其中 $\\mathcal{A}(s_t)$ 是状态 $s_t$ 下可用动作的集合。策略表示为条件概率 $\\pi(a|s)$，即当前状态为 $s$ 时智能体采取动作 $a$ 的概率。这是从状态和动作到采取某动作概率的映射。之后，智能体会收到一个标量奖励 ${r}{t}$ 并将转移存储在智能体的记忆中作为经验。这一过程持续进行，直到智能体达到终止状态。智能体的目标是学习一个策略 ${ \\pi }^{ \\ast }$，使期望折扣回报 ${ R }_{ t }=\\sum { k=0 }^{ \\infty }{ { \\gamma }^{ k }{ r }{ t+k } }$ 最大化，其中折扣因子 $\\gamma \\in (0,1]$ 用于权衡即时奖励和未来奖励的重要性。\n满足马尔可夫性质的强化学习任务可以描述为马尔可夫决策过程（MDPs），其定义为一个五元组 $(\\mathcal{S},\\mathcal{A},\\mathcal{P},\\mathcal{R},\\gamma)$，其中 $\\mathcal{R}$ 是奖励函数 $\\mathcal{R}(s,a)$，$\\mathcal{P}$ 是状态转移概率 $\\mathcal{P}({s}{t+1}|{s}{t},{a}{t})$。马尔可夫性质表明，在给定当前状态的情况下，未来状态与过去状态条件独立。因此，在强化学习任务中，决策和价值被假定为仅是当前状态的函数。马尔可夫性质可以定义为 $p({ s }{ t+1 }|{ s }{ 1 },{ a }{ 1 },...,{ s }{ t },{ a }{ t }) = p({ s }{ t+1 }|{ s }{ t },{ a }{ t })$，这意味着在给定当前状态的情况下，未来状态与过去状态条件独立。满足马尔可夫性质的强化学习任务可以描述为马尔可夫决策过程，其定义为五元组 $(\\mathcal{S},\\mathcal{A},\\mathcal{P},\\mathcal{R},\\gamma)$，其中 $\\mathcal{R}$ 是奖励函数 $\\mathcal{R}(s,a)$，$\\mathcal{P}$ 是状态转移概率 $\\mathcal{P}({s}{t+1}|{s}{t},{a}{t})$。在一个情节任务中，每个情节长度结束后状态会重置，一个情节中的状态、动作和奖励序列构成了策略的轨迹或展开。\n价值函数 价值函数是强化学习系统的核心组件，它构建了一个函数逼近器，用于估计任一状态的长期奖励。它估计智能体处于给定状态（或在给定状态下采取给定动作）时的好坏程度（预期回报）。通过这种方式，函数逼近器利用状态空间的结构来有效地学习观察到的状态的价值，并推广到类似的、未见过的状态的价值。一个典型的价值函数形式可以定义为：\n$${ V }^{ \\pi }(s)=\\mathbb{ E }[R|s,\\pi ]= \\mathbb{E}[\\sum { k=0 }^{ \\infty }{ { \\gamma }^{ k }{ r }{ t+k } }|s,\\pi] $$\n通常我们将 ${ V }^{ \\pi }(s)$ 称为状态价值函数，它衡量在状态 $s$ 开始并遵循策略 $\\pi$ 时的预期折扣回报。当动作遵循最优策略 ${\\pi}^{\\ast}$ 时，状态价值函数可以达到最优：\n$${ V }^{ \\ast }(s)=\\max _{ \\pi }{ { V }^{ \\pi }(s) } \\quad \\forall s\\in \\mathcal{ S }$$\n除了衡量状态的价值之外，还有一个用于衡量动作选择质量的指标，称为状态-动作价值或质量函数 ${Q}^{\\pi}(s,a)$。它定义了在给定状态 $s$ 下选择动作 $a$ 并随后遵循策略 $\\pi$ 的价值。\n$${ Q }^{ \\pi }(s,a)=\\mathbb{ E }[R|s,a,\\pi ]= \\mathbb{E}[\\sum { k=0 }^{ \\infty }{ { \\gamma }^{ k }{ r }{ t+k } }|s,a,\\pi] $$\n状态-动作价值与状态价值 $V^{\\pi}$ 类似，不同之处在于提供了初始动作 $a$，并且策略 $\\pi$ 仅从随后的状态开始执行。最优状态-动作价值函数表示为：\n$${ Q }^{ \\ast }(s,a)=\\max _{ \\pi }{ { Q }^{ \\pi }(s,a) } \\quad \\forall s\\in \\mathcal{ S } , \\forall a\\in \\mathcal{ A } $$\n${ Q }^{ \\ast }(s,a)$ 给出了状态 $s$ 和动作 $a$ 的最大状态-动作价值，这是任何策略可以达到的值。\n这个动作价值函数满足递归性质，这是强化学习设置中价值函数的一个基本属性，它表达了状态值与其后继状态之间的关系：\n$${Q}^{\\pi}(s,a)=\\mathbb{E}{{s}^{\\prime}}[r+\\gamma\\mathbb{E}{{a}^{\\prime}\\sim{\\pi}({s}^{\\prime})}[{Q}^{\\ast}({s}^{\\prime},{a}^{\\prime})]|s,a,\\pi] $$\n与生成绝对状态-动作值 $Q^{\\pi}$ 不同，优势函数表示相对状态-动作值，衡量动作是否比策略的默认行为更好或更差。通常，学习某个动作产生更高奖励比学习采取特定动作的实际回报更容易。优势函数通过以下简单关系表达动作的相对优势：\n$${ A }^{ \\pi }(s,a)={ Q }^{ \\pi }(s,a)-{ V }^{ \\pi }(s) $$\n许多成功的基于值的强化学习算法依赖于优势更新的思想。\n核心强化学习算法 深度 Q-网络 深度强化学习（DRL）应用深度神经网络来表示强化学习方法中的价值函数。DRL算法在多个挑战性任务领域取得了超人类表现，这归功于深度学习强大的函数逼近和表示学习能力。DQN算法在Atari系列游戏中通过像素输入达到了人类水平的表现。它使用神经网络 $Q(s,a;\\theta)$ 参数化质量函数 $Q$，从而逼近 $Q$ 值。DQN算法的两个主要技术，即使用目标网络和经验回放，可以稳定和有效地学习价值函数。在每次迭代中，网络的参数更新通过最小化以下损失函数来实现：\n$${L}{i}({\\theta}{i})=\\mathbb{E}{s,a,r,{s}^{\\prime}}[({y}{i}^{DQN}-Q(s,a;{\\theta}_{i}))^{2}]$$\n其中\n$${y}_{i}^{DQN}=r+\\gamma \\underset {{a}^{\\prime}}{max}Q({s}^{\\prime},{a}^{\\prime};{\\theta}^{-}) $$\n在其中，${\\theta}^{-}$ 是目标网络的参数。第一稳定方法是固定目标网络的参数，而不是基于其自身快速波动的$Q$值估计来计算TD误差。第二个方法是经验回放，它使用缓冲区存储一定大小的转换$({s}{t},{a}{t},{s}{t+1},{r}{t+1})$，可以进行离策略训练，并增强数据采样的效率。\n在DQN算法引发这一领域之后，价值基础的强化学习设置经历了一系列改进。为了减少DQN中被高估的$Q$值，van Hasselt等人提出了双重DQN算法。Wang等人提出了一种对抗Q网络架构，用于分别估计状态值函数$V(s)$和相关的优势函数$A(s,a)$。Tamar等人提出了一种价值迭代网络，能有效地学习规划，并在许多强化学习任务中实现更好的泛化。Schaul等人开发了建立在双重DQN之上的PER方法，它使经验回放过程比统一重播所有转换更加高效和有效。\nDueling 网络结构 与标准的单序列$Q$网络设计不同，对抗网络结构包括两个序列（流）的网络（A网络和V网络），分别学习动作优势函数和状态值函数。这种构造将价值函数和优势函数解耦，并结合这两个流来产生状态-动作值函数的估计，使用特殊的聚合模块。这两个流共享一个公共的特征提取层（或较低层）。深度$Q$网络专注于估计每个状态-动作对的价值。然而，对抗网络的想法是分别估计与动作无关的状态函数和依赖于动作的优势函数，因为在强化学习环境中，并非所有状态都与特定动作相关，有许多状态是与动作无关的，在这些状态下，智能体不需要改变动作来适应新的状态。因此，估计这些状态-动作对的值是无意义且低效的。对抗网络首次由Wang等人提出，通过这一改变，训练效率比单一流$Q$网络大大提高。根据Wang的工作，对抗网络在离散动作空间任务中取得了新的技术成果。简而言之，对抗网络生成的$Q$值对性能提升比深度$Q$网络在强化学习任务中更有优势。\n策略梯度 上述方法间接地通过估计值函数学习策略 $\\pi(s)$。这些基于值的方法在处理离散动作领域的问题时非常有效。然而，当处理具有连续动作空间的问题，如物理控制任务时，基于值的方法不能直接应用，并且很难确保结果的收敛性，因为它依赖于每个动作的$Q$值。将基于值的算法（如DQN）应用于连续域的一个显而易见的方法是将动作空间离散化为若干固定动作。然而，这种方法有许多缺点和局限性，如可能丢失关于动作域结构的重要信息。\n在基于策略的方法中不存在这种担忧，因为策略网络直接输出智能体的动作，而无需估计动作值函数。它们直接参数化控制策略 $\\pi(a|s;\\theta)$ 并更新参数 $\\theta$ 来优化累积奖励，因此，基于策略的方法比基于值的方法更适用于连续控制问题，如机器人控制任务。\n策略梯度（PG）是一种吸引人的基于策略的算法，它优化参数化策略 ${\\pi}{\\theta}(a|s)=\\mathbb{P}[a|s;\\theta]$，按照策略参数的期望累积奖励梯度 ${\\nabla}{\\theta}J({\\pi}{\\theta})$ 进行优化。策略梯度方法在高维或连续动作空间中非常有效，并且可以学习到随机策略。在强化学习任务中，智能体的目标是找到最大化目标函数 $J(\\pi)$ 的参数 $\\theta$。一个典型的性能目标是平均奖励函数：$J(\\pi)=\\mathbb{E}[R|{\\pi}{\\theta}]$。策略梯度定理提供了关于策略 $\\pi$ 参数 $\\theta$ 的梯度：\n$${\\nabla}{\\theta}J({\\pi}{\\theta})=\\int {\\mathcal{S}}^{ }{{\\rho}^{\\pi} }\\int{\\mathcal{A}}^{ }{{\\nabla}{\\theta}}{\\pi}{\\theta}(a|s){Q}^{ \\pi}(s,a)dads \\ \\quad\\quad\\quad\\quad=\\mathbb{E}{s\\sim{\\rho}^{\\pi},a\\sim {\\pi}^{\\theta}}[{\\nabla}{\\theta} log{\\pi}^{\\theta}(a|s){Q}^{\\pi}(s,a)] $$\n其中，${\\rho}^{\\pi}(s)$ 是状态分布。未知部分 ${Q}^{\\pi}(s,a)$ 通常通过使用实际回报 ${ R }_{ t }=\\sum { k=0 }^{ \\infty }{ { \\gamma }^{ k }{ r }{ t+k } }$ 作为每个 ${Q}^{\\pi}(s_t,a_t)$ 的近似来估计。基于这个定理，Silver等人提出了确定性策略梯度（DPG）算法用于梯度估计，它比通常的随机策略梯度方法更有效。O'Donoghue等人提到了一种结合PGQL的新技术，并讨论了在强化学习环境中实现这一技术的实际方法。\nActor-Critic 算法 常规的策略梯度方法由于梯度估计的方差较大，通常表现出收敛缓慢的特点。演员-评论家方法通过引入评论家网络来估计当前策略的值，试图通过这种方式减少方差，并利用这些估计值来更新演员策略参数，以提升性能。\n动作选择策略称为演员 ${\\pi}{\\theta}:\\mathcal{S}\\rightarrow \\mathcal{A}$，它在不需要对值函数进行优化的情况下做出决策，将状态表示映射到动作选择概率上。值函数称为评论家 ${Q}{\\phi}^{\\pi}: \\mathcal{S} \\times \\mathcal{A} \\rightarrow \\mathbb{R}$，它估计预期回报以减少方差并加速学习，将状态映射到预期的累积未来奖励上。\n演员和评论家是两个独立的网络，共享相同的观察。在每个步骤中，演员网络选择的动作也是评论家网络的输入因子。在策略改进过程中，评论家网络通过DQN估计当前策略的状态-动作值，然后演员网络根据这些估计值更新其策略以改进$Q$值。相比于以前的纯策略梯度方法，使用评论家网络来评估当前策略更有助于收敛和稳定性。状态-动作值评估越好，学习性能的方差就越低。在评论家网络中进行更好的策略评估是重要且有帮助的。\n基于策略梯度的演员-评论家算法在许多现实应用中非常有用，因为它们可以使用低方差的梯度估计来寻找最优策略。Lillicrap等人提出了DDPG算法，将演员-评论家方法与DQN的见解结合起来，解决了模拟物理任务，并广泛应用于许多机器人控制任务。该算法使用两个神经网络：演员网络学习确定性策略，评论家网络逼近当前策略的Q函数。\n总结 强化学习（RL）代表了机器学习领域的一个强大范式，灵感来自行为心理学，使得智能体能够在复杂环境中做出决策，以最大化累积奖励。作为马尔可夫决策过程（MDP）形式化，RL任务涉及状态、动作、奖励和转移概率。例如，深度 Q 网络（DQN）等算法利用深度神经网络高效逼近 Q 值，从而在离散动作空间中促进决策制定。\n基于价值的RL方法，例如DQN，通过估计状态-动作值来优化策略。演员-评论家方法改进了传统的策略梯度方法，引入评论家网络来估计值函数，从而减少方差并增强学习稳定性。这些进展通过像深度确定性策略梯度（DDPG）这样的算法扩展到连续动作空间，结合了确定性策略和 Q 函数逼近。\n策略梯度方法直接基于预期奖励的梯度估计优化策略，在连续动作空间中表现出色。对于提高训练效率的一个重要贡献是 dueling 网络结构，它分离了状态值和优势函数，重视依赖于动作的优势。\n总体而言，强化学习通过价值估计、策略优化以及在机器人学和游戏玩法等多样领域的应用中的创新不断发展。神经网络架构和学习算法的进步持续推动着强化学习研究和应用的进步。近年来的趋势包括将 RL 适应连续动作空间，与自然语言处理和计算机视觉等领域融合，提高采样效率和训练稳定性。未来的方向包括通过跨学科合作提升 RL 在解决现实挑战中的适用性，并解决部署中的伦理考量。\n","link":"https://mengwoods.github.io/cn/post/dl/008-drl-summary/","section":"post","tags":null,"title":"强化学习理论基础介绍"},{"body":"基于 Deep Learning (2017, MIT) 书.\n1 概述 概率论是表示不确定性陈述的数学框架。在AI领域中，我们以两种主要方式使用概率论。首先，概率定律告诉我们AI系统应该如何推理，因此我们设计算法来计算或近似使用概率论得出的各种表达式。其次，我们可以使用概率和统计来理论上分析所提出的AI系统的行为。\n2 知识 2.1 离散变量和概率质量函数（PMF） 对离散变量的概率分布可以用概率质量函数（PMF）来描述。 离散变量$x$遵循分布$P(x)$:$\\mathrm{x}\\sim P(x)$。\n联合概率分布是许多变量的概率分布：$P(\\mathrm{x}=x, \\mathrm{y}=y)$，或者$P(x,y)$。\nPMF的特性：\n$P$的定义域必须是$\\mathrm{x}$的所有可能状态的集合。 对于$\\forall x\\in \\mathrm{x}$，$0\\leq P(x) \\leq 1$。 $\\sum_{x\\in \\mathrm{x}}P(x)=1$。 均匀分布：$P(\\mathrm{x}=x_i)=\\dfrac{1}{K}$。\n2.2 连续变量和概率密度函数（PDF） 概率密度函数（PDF）用于描述连续随机变量的概率分布。PDF的函数$p$必须满足以下特性：\n$p$的定义域是$\\mathrm{x}$的所有可能状态的集合。 对于$\\forall x\\in \\mathrm{x}$，$p(x)\\geq0$。注意不要求$p(x)\\leq 1$。 $\\int p(x)dx=1$。 PDF不是概率，PDF与PMF不同，PDF可以大于1。离散和连续随机变量的定义方式不同。对于连续随机变量，必要条件是$\\int p(x)dx=1$。PDF不直接给出特定状态的概率，而是给出落入$\\delta x$的无穷小区域内的概率，即$p(x)\\delta x$。变量$x$位于区间$[a,b]$的概率由$\\int_{[a,b]}p(x)dx$给出。\n均匀分布 $u(x;a,b)=\\dfrac{1}{b-a}$，$a$和$b$是区间的端点。分号表示参数化。$x$是函数的参数，$a$和$b$是参数。$x\\sim U(a,b)$表示$x$遵循均匀分布。\n2.3 边缘概率 对变量子集的概率分布称为边缘概率分布。例如，对于离散随机变量$\\mathrm{x}$和$\\mathrm{y}$，已知$P(\\mathrm{x},\\mathrm{y})$，可以使用求和规则计算$P(\\mathrm{x})$：$\\forall x\\in \\mathrm{x}$，$P(\\mathrm{x}=x)=\\sum_{y}P(\\mathrm{x}=x, \\mathrm{y}=y)$。对于连续变量，需要使用积分而不是求和：$p(x)=\\int p(x,y)dy$。\n2.4 条件概率 计算某个事件发生的概率，已知某些其他事件已发生。这是条件概率。$P(\\mathrm{y}=y|\\mathrm{x}=x)$，$\\mathrm{x}=x$是条件。可以使用公式$P(\\mathrm{y}=y|\\mathrm{x}=x)=\\dfrac{P(\\mathrm{y}=y,\\mathrm{x}=x)}{P(\\mathrm{x}=x)}$来计算。\n条件概率仅在$P(\\mathrm{x}=x)\u0026gt;0$时定义。我们不能计算条件是从不发生事件的条件概率。\n2.5 条件概率的链式法则 任何多个随机变量的联合概率分布可以分解为对单个变量的条件分布，这称为链式法则或乘法规则。$P(\\mathrm{x}^{(1)},\\ldots,\\mathrm{x}^{(n)})=P(\\mathrm{x}^{(1)})\\Pi_{i=2}^nP(\\mathrm{x}^{(i)}|\\mathrm{x}^{(1)},\\ldots,\\mathrm{x}^{(i-1)})$。\n一些例子：\n$P(a,b,c)=P(a|b,c)P(b,c)$;\n$P(b,c)=P(b|c)P(c)$;\n$P(a,b,c)=P(a|b,c)P(b|c)P(c)$。\n2.6 独立性和条件独立性 如果$x$和$y$是独立的（$x\\perp y$），则：$\\forall x\\in \\mathrm{x}, y \\in \\mathrm{y}, p(\\mathrm{x}=x, \\mathrm{y}=y)=p(\\mathrm{x}=x)p(\\mathrm{y}=y)$。\n给定随机变量$z$，如果$x$和$y$在条件$z$下独立（$x\\perp y|z$），则：\n$\\forall x\\in \\mathrm{x}, y\\in \\mathrm{y}, z\\in \\mathrm{z}, p(\\mathrm{x}=x, \\mathrm{y}=y, \\mathrm{z}=z)=p(\\mathrm{x}=x|\\mathrm{z}=z)p(\\mathrm{y}=y|\\mathrm{z}=z)$\n2.7 期望、方差和协方差 期望\n对于离散变量：$\\mathbb{E}{\\mathrm{x}\\sim P}[f(x)]=\\sum{x}P(x)f(x)$。\n对于连续变量：$\\mathbb{E}_{\\mathrm{x}\\sim P}[f(x)]=\\int{P(x)f(x)}dx$。\n期望是线性的：$\\mathbb{E}{\\mathrm{x}}[\\alpha f(x)+\\beta g(x)]=\\alpha \\mathbb{E}{\\mathrm{x}}[f(x)] + \\beta \\mathbb{E}_{\\mathrm{x}}[g(x)]$\n方差\n$Var(f(x))=\\mathbb{E}[(f(x)-\\mathbb{E}[f(x)])^2]$\n当方差很小时，$f(x)$的值会聚集在其期望值附近。方差的平方根称为标准差。\n协方差\n协方差给出两个值之间线性相关的程度，以及这些变量的尺度：\n$Cov(f(x),g(y))=\\mathbb{E}[(f(x)-\\mathbb{E}[f(x)])(g(y)-\\mathbb{E}[g(y)])]$\n协方差的绝对值较高意味着这些值变化很大，并且同时远离各自的均值。正号表示两个变量倾向于同时取相对较高的值。负号表示一个变量取得高值，另一个变量取得低值，反之亦然。\n协方差与相关的关系：\n独立变量的协方差为零。非零协方差的变量是相关的。 独立性是比零协方差更强的要求。两个变量可以相关，但协方差为零。 随机向量$\\mathbf{x}\\in \\mathbb{R}^n$的协方差矩阵是一个$n\\times n$矩阵：$Cov(\\mathbf{x})_{i,j}=Cov(\\mathbf{x}_i,\\mathbf{x}_j)$ 协方差的对角线元素给出了方差：$Cov(\\mathbf{x}_i,\\mathbf{x}_i)=Var(\\mathbf{x}_i)$。\n2.8 常见概率分布 在机器学习中有几个有用的概率分布。\n伯努利分布\n分布在单个二进制随机变量上。特性：\n$P(\\mathbf{x}=1)=\\phi$，$p(\\mathbf{x}=0)=1-\\phi$ $P(\\mathbf{x}=x)=\\phi^x(1-\\phi)^{1-x}$ $\\mathbb{E}_{\\mathbf{x}}[\\mathbf{x}]=\\phi$ $Var_\\mathbf{x}(\\mathbf{x})=\\phi(1-\\phi)$ 多项式分布\n或分类分布，是具有$k$个不同状态的单个离散变量的分布。\n高斯分布\n或正态分布： $\\mathcal{N}(x;\\mu,\\sigma^2)=\\sqrt{\\dfrac{1}{2\\pi \\sigma^2}}\\exp(-\\dfrac{1}{2\\sigma^2(x-\\mu)^2})$\n$\\mu$给出了中心峰值的坐标，这也是分布的均值：$\\mathbb{E}[\\mathbf{x}]=\\mu$ 分布的标准差：$\\sigma$ 方差：$\\sigma^2$ 指数和拉普拉斯分布\n指数分布：$p(x;\\lambda)=\\lambda 1_{x\\geq 0} \\exp(-\\lambda x)$\n对于所有负值的$x$，概率为零。\n拉普拉斯分布：$Laplace(x;\\mu,\\gamma)=\\dfrac{1}{2\\gamma}\\exp(-\\dfrac{|x-\\mu|}{\\gamma})$\n狄拉克分布和经验分布\n狄拉克分布：$p(x)=\\delta (x-\\mu)$\n经验分布：$\\hat{p}(x)=\\dfrac{1}{m}\\sum_{i=1}^m\\delta(x-x^{(i)})$\n2.9 常见函数的有用性质 Logistic sigmoid 函数\n$\\sigma(x)=\\dfrac{1}{1+\\exp(-x)}$\n它通常用于生成 Bermoulli 分布的 $\\phi$ 参数。当其参数非常正或负时，sigmoid 函数饱和，意味着函数变得非常平坦，对其输入的微小变化不敏感。\nSoftplus 函数\n$\\zeta(x)=\\log(1+\\exp(x))$\n该函数可用于生成正态分布的 $\\beta$ 或 $\\sigma$ 参数。\n重要性质\n$\\sigma(x)=\\dfrac{\\exp(x)}{\\exp(x)+1}$ $\\dfrac{d}{dx}\\sigma(x)=\\sigma(x)(1-\\sigma(x))$ $1-\\sigma(x)=\\sigma(-x)$ $\\log\\sigma(x) = -\\zeta(-x)$ $\\dfrac{d}{dx}\\zeta(x)=\\sigma (x)$ $\\forall x\\in (0,1), \\sigma^{-1}(x)=\\log(\\dfrac{x}{1-x})$ $\\forall x \u0026gt; 0, \\zeta^{-1}(x)=\\log (\\exp(x)-1)$ $\\zeta(x)=\\int_{-\\infin}^{x}\\sigma(y)dy$ $\\zeta (x) - \\zeta(-x) = x$ 2.10 贝叶斯定理 $P(x|y)=\\dfrac{P(x)P(y|x)}{P(y)}$\n通过 $P(y|x)$ 计算 $P(x|y)$，注意 $P(y)=\\sum_xP(y|x)P(x)$。贝叶斯定理是一种在拥有一些信息情况下计算某件事发生可能性的方法。\n3 应用问题 问题1：有一个公平的硬币（一面是正面，一面是反面）和一个不公平的硬币（两面都是反面）。你随机选择一个硬币，抛掷5次，观察到全部5次都是反面。你抛的是不公平的硬币的几率是多少？\n定义 $U$ 为抛出不公平硬币的情况；$F$ 表示抛出公平硬币。$5T$ 表示我们连续抛出5次正面的事件。\n我们知道 $P(U) = P(F) = 0.5$，需要求解 $P(U|5T)$。 $$P(U|5T) = \\dfrac{P(5T|U)P(U)}{P(5T)}$$ $$=\\dfrac{10.5}{P(5T|U)P(U)+P(5T|F)P(F)}$$ $$=\\dfrac{0.5}{10.5+0.5^5*0.5}\\approx0.97$$ 因此，选择了不公平硬币的概率约为97%。\n问题2：你和你的朋友正在玩一个游戏。你们两个将继续抛硬币，直到序列 HH 或 TH 出现为止。如果先出现 HH，你赢。如果先出现 TH，你的朋友赢。每个人的获胜概率是多少？\nP(HH 先出现而不是 TH) = P(前两次抛出 HH) = 1/4\nP(TH 先出现而不是 HH) = P(首次为 T) + P(前两次为 HT) = 1/2 + 1/4 = 3/4\n问题3：1000人中有1人患有一种特定的疾病，并且有一种检测方法，如果患有该疾病，检测正确率为98%。如果没有患病，检测错误率为1%。如果有人检测为阳性，他们患病的几率是多少？\nP(D) = 1/1000 表示患有疾病的概率\nP(H) = 1 - P(D) = 999/1000 表示健康的概率\nP(P|D) = 98% 表示如果患有疾病，则检测为阳性的概率\nP(P|H) = 1% 表示如果没有患病，则检测为阳性的概率\n需要求解 P(D|P)\n$$P(D|P)=\\dfrac{P(P|D)P(D)}{P(P)}$$ $$= \\dfrac{98/100*1/1000}{P(P|D)P(D) + P(P|H)P(H)}$$ $$= \\dfrac{0.098%}{98%*1/1000 + 1% * 999/1000}$$ $$\\approx 8.94%$$\n因此，如果有人检测为阳性，则他们患病的概率约为0.0894或8.94%。\n","link":"https://mengwoods.github.io/cn/post/dl/001-probability/","section":"post","tags":null,"title":"深度学习中的概率知识"},{"body":"应用案例\n使用 Scikit-learn 实现 PCA 使用Scikit-learn库执行PCA过程以对数字数据进行降维。然后比较原始数据和重构数据之间的差异。\n输入数据 导入库，并可视化源输入数据。\n1# 导入所需的库 2import numpy as np 3import matplotlib.pyplot as plt 4from sklearn.datasets import load_digits 5from sklearn.decomposition import PCA 6from sklearn.metrics import mean_squared_error 1# 加载数字数据集 2digits = load_digits() 3X = digits.data 4y = digits.target 5 6# 计算原始数据大小 7original_size = X.nbytes / (1024 * 1024) # in megabytes 8print(\u0026#34;original data size is: %.2f MB\u0026#34; % original_size) original data size is: 0.88 MB 1# 将前10个样本作为图像显示 2fig, axes = plt.subplots(1, 10, figsize=(12, 4)) 3for i in range(10): 4 axes[i].imshow(X[i].reshape(8, 8), cmap=\u0026#39;gray\u0026#39;) 5 axes[i].set_title(f\u0026#34;Label: {y[i]}\u0026#34;) 6 axes[i].axis(\u0026#39;off\u0026#39;) 7plt.tight_layout() 8plt.show() 重建结果 定义函数以计算重构误差和执行PCA\n1# Function to calculate reconstruction error 2def reconstruction_error(original, reconstructed): 3 return mean_squared_error(original, reconstructed) 4 5# 函数用于执行PCA并使用n_components重构数据。 6def perform_pca(n_components): 7 pca = PCA(n_components=n_components) 8 X_pca = pca.fit_transform(X) 9 X_reconstructed = pca.inverse_transform(X_pca) 10 return X_reconstructed, pca 1# 执行PCA，并可视化结果 2def analyze_pca(n_components): 3 X_reconstructed, pca = perform_pca(n_components) 4 reconstruction_error_val = reconstruction_error(X, X_reconstructed) 5 print(f\u0026#34;Number of Components: {n_components}, Reconstruction Error: {reconstruction_error_val}\u0026#34;) 6 7 # 压缩文件的大小 8 compressed_size = (pca.components_.nbytes + pca.mean_.nbytes + X_reconstructed.nbytes) / (1024 * 1024) # in megabytes 9 print(f\u0026#34;Size of Compressed File: {compressed_size} MB\u0026#34;) 10 11 # 大小差异 12 size_difference = original_size - compressed_size 13 print(f\u0026#34;Difference in Size: {size_difference} MB\u0026#34;) 14 15 # 绘制每个数字的原始和重构图像 16 fig, axes = plt.subplots(2, 10, figsize=(10, 2)) 17 for digit in range(10): 18 digit_indices = np.where(y == digit)[0] # Indices of samples with the current digit 19 original_matrix = X[digit_indices[0]].reshape(8, 8) # Take the first sample for each digit 20 reconstructed_matrix = np.round(X_reconstructed[digit_indices[0]].reshape(8, 8), 1) # Round to one decimal place 21 axes[0, digit].imshow(original_matrix, cmap=\u0026#39;gray\u0026#39;) 22 axes[0, digit].axis(\u0026#39;off\u0026#39;) 23 axes[1, digit].imshow(reconstructed_matrix, cmap=\u0026#39;gray\u0026#39;) 24 axes[1, digit].axis(\u0026#39;off\u0026#39;) 25 26 plt.suptitle(f\u0026#39;Reconstruction with {n_components} Components\u0026#39;) 27 plt.show() 28 29 # 打印第一个数据的原始矩阵 30 print(\u0026#34;Original Matrix of the First Data:\u0026#34;) 31 print(original_matrix) 32 33 # 打印重构矩阵 34 print(\u0026#34;\\nReconstruction Matrix of the First Data:\u0026#34;) 35 print(reconstructed_matrix) 分析使用一个主成分时的结果\n1analyze_pca(1) Number of Components: 1, Reconstruction Error: 15.977678462238496 Size of Compressed File: 0.87841796875 MB Difference in Size: -0.0009765625 MB Original Matrix of the First Data: [[ 0. 0. 11. 12. 0. 0. 0. 0.] [ 0. 2. 16. 16. 16. 13. 0. 0.] [ 0. 3. 16. 12. 10. 14. 0. 0.] [ 0. 1. 16. 1. 12. 15. 0. 0.] [ 0. 0. 13. 16. 9. 15. 2. 0.] [ 0. 0. 0. 3. 0. 9. 11. 0.] [ 0. 0. 0. 0. 9. 15. 4. 0.] [ 0. 0. 9. 12. 13. 3. 0. 0.]] Reconstruction Matrix of the First Data: [[-0. 0.4 6.4 12.6 12. 6.3 1.4 0.1] [ 0. 2.6 11.7 11.2 10.5 9.4 1.9 0.1] [ 0. 3. 9.4 5.8 8. 8.7 1.6 0. ] [ 0. 2.1 7.7 9. 11.1 7.8 2. 0. ] [ 0. 1.5 5.6 8.2 9.8 8.5 2.8 0. ] [ 0. 1. 5.2 5.9 6.5 8.2 3.7 0. ] [ 0. 0.8 7.8 9. 8.8 9.5 4.1 0.2] [ 0. 0.4 6.8 12.9 11.9 7.3 2.3 0.4]] 分析使用五个主成分时的结果\n1analyze_pca(5) Number of Components: 5, Reconstruction Error: 8.542447616249266 Size of Compressed File: 0.88037109375 MB Difference in Size: -0.0029296875 MB Original Matrix of the First Data: [[ 0. 0. 11. 12. 0. 0. 0. 0.] [ 0. 2. 16. 16. 16. 13. 0. 0.] [ 0. 3. 16. 12. 10. 14. 0. 0.] [ 0. 1. 16. 1. 12. 15. 0. 0.] [ 0. 0. 13. 16. 9. 15. 2. 0.] [ 0. 0. 0. 3. 0. 9. 11. 0.] [ 0. 0. 0. 0. 9. 15. 4. 0.] [ 0. 0. 9. 12. 13. 3. 0. 0.]] Reconstruction Matrix of the First Data: [[ 0. 0.2 5.2 11.1 12.1 7. 1.6 0.1] [ 0. 2.1 11.2 10.7 9.7 9.6 2.3 0.2] [ 0. 3.1 11.2 6.2 6. 9.2 2.5 0.1] [ 0. 3.1 10.3 9. 9.6 9.6 2.9 0. ] [ 0. 2.2 6. 5.3 8. 11.6 3.9 0. ] [ 0. 1.2 4.2 1.9 4.9 11.7 5.1 0. ] [ 0. 0.6 6.7 6.2 8.8 12.1 4.4 0.2] [ 0. 0.2 5.4 12.1 13.4 8.2 1.8 0.3]] 使用更多的主成分，重构结果会更好。接下来我们将手动计算PCA矩阵。\n手动实现 PCA 手动逐步执行PCA分析。\n输入数据 打印数据\n1# 然后使用逐步的方法计算PCA步骤； 2# 取第一个数据点进行分析 3first_data = X[0] 4print(\u0026#34;Raw input data: \\n\u0026#34;, X[0]) 5# 将数据点重新整形为二维数组（图像） 6input_matrix = first_data.reshape(8, 8) 7 8print(\u0026#34;Input matrix: \u0026#34;) 9for row in input_matrix: 10 print(\u0026#34; \u0026#34;.join(f\u0026#34;{val:4.0f}\u0026#34; for val in row)) 11 12# 打印原始矩阵（图像） 13plt.imshow(input_matrix, cmap=\u0026#39;gray\u0026#39;) 14plt.title(\u0026#34;Input matrix (Image)\u0026#34;) 15plt.axis(\u0026#39;off\u0026#39;) 16plt.show() Raw input data: [ 0. 0. 5. 13. 9. 1. 0. 0. 0. 0. 13. 15. 10. 15. 5. 0. 0. 3. 15. 2. 0. 11. 8. 0. 0. 4. 12. 0. 0. 8. 8. 0. 0. 5. 8. 0. 0. 9. 8. 0. 0. 4. 11. 0. 1. 12. 7. 0. 0. 2. 14. 5. 10. 12. 0. 0. 0. 0. 6. 13. 10. 0. 0. 0.] Raw data shape: (64,) Input matrix: 0 0 5 13 9 1 0 0 0 0 13 15 10 15 5 0 0 3 15 2 0 11 8 0 0 4 12 0 0 8 8 0 0 5 8 0 0 9 8 0 0 4 11 0 1 12 7 0 0 2 14 5 10 12 0 0 0 0 6 13 10 0 0 0 居中数据 这个均值计算有助于我们理解每个特征的平均值，这对于居中数据和在随后的步骤中计算协方差矩阵至关重要。 居中数据是PCA中的关键预处理步骤，它增强了结果的解释性，消除了偏差，并确保了计算中的数值稳定性。\n1# 步骤1：计算每个特征（列）的均值 2mean_vec = np.mean(input_matrix, axis=0) 3print(mean_vec) [ 0. 2.25 10.5 6. 5. 8.5 4.5 0. ] 1# 步骤2：从每个特征中减去均值 2centered_matrix = input_matrix - mean_vec 3print(centered_matrix) [[ 0. -2.25 -5.5 7. 4. -7.5 -4.5 0. ] [ 0. -2.25 2.5 9. 5. 6.5 0.5 0. ] [ 0. 0.75 4.5 -4. -5. 2.5 3.5 0. ] [ 0. 1.75 1.5 -6. -5. -0.5 3.5 0. ] [ 0. 2.75 -2.5 -6. -5. 0.5 3.5 0. ] [ 0. 1.75 0.5 -6. -4. 3.5 2.5 0. ] [ 0. -0.25 3.5 -1. 5. 3.5 -4.5 0. ] [ 0. -2.25 -4.5 7. 5. -8.5 -4.5 0. ]] 协方差计算 计算居中数据的协方差矩阵。\n1# 使用np.dot计算协方差。Bessel修正在末尾减1。 https://www.uio.no/studier/emner/matnat/math/MAT4010/data/forelesningsnotater/bessel-s-correction---wikipedia.pdf 2cov_matrix = np.dot(centered_matrix.T, centered_matrix) / (centered_matrix.shape[0] - 1) 3 4# 或者使用np.cov计算协方差 5# cov_matrix = np.cov(centered_matrix, rowvar=False) 6 7print(cov_matrix) [[ 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 4.21428571 2.28571429 -13.14285714 -9.42857143 4.14285714 6.14285714 0. ] [ 0. 2.28571429 14. -9.42857143 -4.85714286 17. 6.28571429 0. ] [ 0. -13.14285714 -9.42857143 43.42857143 29.57142857 -12.57142857 -17.85714286 0. ] [ 0. -9.42857143 -4.85714286 29.57142857 26. -7. -17.57142857 0. ] [ 0. 4.14285714 17. -12.57142857 -7. 28.85714286 11. 0. ] [ 0. 6.14285714 6.28571429 -17.85714286 -17.57142857 11. 14.85714286 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. ]] 矩阵特征分解 1# 步骤4：计算协方差矩阵的特征值和特征向量 2eigenvalues, eigenvectors = np.linalg.eig(cov_matrix) 3 4print(eigenvalues) 5print(eigenvectors) [8.92158455e+01 3.14545089e+01 7.61850164e+00 2.85144338e+00 2.01453633e-01 1.53898738e-02 0.00000000e+00 0.00000000e+00] [[ 0. 0. 0. 0. 0. 0. 1. 0. ] [-0.20365153 0.09344175 0.07506402 -0.23052329 -0.41043409 -0.85003703 0. 0. ] [-0.22550077 -0.48188982 0.20855091 0.79993174 -0.1168451 -0.14104805 0. 0. ] [ 0.65318552 -0.28875672 -0.59464342 0.12374602 0.11324705 -0.32898247 0. 0. ] [ 0.48997693 -0.31860576 0.39448425 -0.20610464 -0.63307453 0.24399318 0. 0. ] [-0.33563583 -0.75773097 -0.0607778 -0.49775699 0.24837474 0.00681139 0. 0. ] [-0.35818338 -0.00212894 -0.66178497 0.03760326 -0.58531429 0.29955628 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 1. ]] 选择与最大特征值对应的特征向量作为主成分。\n1# 步骤5：选择与最大特征值对应的主成分 2max_eigenvalue_index = np.argmax(eigenvalues) 3principal_component = eigenvectors[:, max_eigenvalue_index] 4print(principal_component) [ 0. -0.20365153 -0.22550077 0.65318552 0.48997693 -0.33563583 -0.35818338 0. ] 1# 步骤6：将数据投影到主成分上 2reduced_data = np.dot(centered_matrix, principal_component) 3 4# 打印降维后的数据 5print(\u0026#34;Reduced data (1 principal component):\\n\u0026#34;, reduced_data) Reduced data (1 principal component): [12.35977044 5.86229378 -8.32285024 -8.14946302 -7.7867473 -8.41834525 1.49545914 12.95988243] 到目前为止，数据已从 8x8 矩阵压缩为 8x1 向量。\n重构数据 现在基于降维后的结果来重新组建原数据，并展示效果。\n1# 步骤7：重构数据 2reconstructed_data = np.dot(reduced_data.reshape(-1, 1), principal_component.reshape(1, -1)) 3 4# 步骤8：将均值添加回重构的数据 5reconstructed_data += mean_vec 6 7# 步骤9：可视化原始数据和重构数据 8fig, axes = plt.subplots(1, 2, figsize=(12, 6)) 9 10# 原始数据 11axes[0].imshow(input_matrix, cmap=\u0026#39;gray\u0026#39;) 12axes[0].set_title(\u0026#39;Original Data\u0026#39;) 13axes[0].axis(\u0026#39;off\u0026#39;) 14 15# Reconstructed data 16axes[1].imshow(reconstructed_data.real, cmap=\u0026#39;gray\u0026#39;) 17axes[1].set_title(\u0026#39;Reconstructed Data\u0026#39;) 18axes[1].axis(\u0026#39;off\u0026#39;) 19 20plt.show() ","link":"https://mengwoods.github.io/cn/post/math/003-pca-application/","section":"post","tags":null,"title":"主成分分析 (PCA) 的应用案例"},{"body":"Based on Deep Learning (2017, MIT) book.\n本文基于Deep Learning (2017, MIT)，推导过程补全了所涉及的知识及书中推导过程中跳跃和省略的部分。 blog\n1 概述 现代数据集，如网络索引、高分辨率图像、气象学、实验测量等，通常包含高维特征，高纬度的数据可能不清晰、冗余，甚至具有误导性。数据可视化和解释变量之间的关系很困难，而使用这种高维数据训练的神经网络模型往往容易出现过拟合（维度诅咒）。 主成分分析（PCA）是一种简单而强大的无监督机器学习技术，用于数据降维。它旨在从大型变量集中提取一个较小的数据集，同时尽可能保留原始信息和特征（有损压缩）。PCA有助于识别数据集中最显著和有意义的特征，使数据易于可视化。应用场景包括：统计学、去噪和为机器学习算法预处理数据。\n主成分是什么？ 主成分是构建为原始变量的线性组合的新变量。这些新变量是不相关的，并且包含原始数据中大部分的信息。 2 背景数学知识 这些知识对下一节的推导很重要。\n正交向量和矩阵： 如果两个向量垂直，则它们是正交的。即两个向量的点积为零。 正交矩阵是一个方阵，其行和列是相互正交的单位向量；每两行和两列的点积为零，每一行和每一列的大小为1。 如果$A^T=A^{-1}$或$AA^T=A^TA=I$，则$A$是正交矩阵。 在机器人学中，旋转矩阵通常是一个$3\\times3$的正交矩阵，在空间变换中它会旋转向量的方向但保持原始向量的大小。 矩阵、向量乘法规则： $(AB)^T=B^TA^T$，两个矩阵的乘积的转置。 $\\vec{a}^T\\vec{b}=\\vec{b}^T\\vec{a}$，两个结果都是标量，标量的转置是相同的。 $(A + B)C = AC + BC$，乘法是可分配的。 $AB \\neq{} BA$，乘法一般不满足交换律。 $A(BC)=(AB)C$，乘法满足结合律。 对称矩阵： $A=A^T$，$A$是对称矩阵。 $X^TX$是对称矩阵，因为$(X^TX)^T=X^TX$。 向量导数规则（$B$是常量矩阵）： $d(x^TB)/dx=B$ $d(x^Tx)/dx=2x$ $d(x^TBx)/dx=2Bx$ 矩阵迹规则： $Tr(A)=Tr(A^T)$ $Tr(AB)=Tr(BA)$ $Tr(A)=\\sum_i{\\lambda_i}$，其中$\\lambda$是$A$的特征值。 迹在循环移位下不变：$Tr(ABCD)=Tr(BCDA)=Tr(CDAB)=Tr(DABC)$ 向量和矩阵范数： 向量的$L^2$范数，也称为欧几里得范数：$||x||_2=\\sqrt{\\sum_i|x_i|^2}$。 通常使用平方的$L^2$范数来衡量向量的大小，可以计算为$x^Tx$。 Frobenius范数用于衡量矩阵的大小：$||A||F=\\sqrt{\\sum{i,j}A^2_{i,j}}$ Frobenius范数是所有矩阵元素的绝对平方和的平方根。 Frobenius范数是矩阵版本的欧几里得范数。 特征值分解和特征值： 方阵$A$的特征向量是一个非零向量$v$，使得$A$的乘法仅改变$v$的比例：$Av=\\lambda v$。$\\lambda$是特征值，$v$是特征向量。 假设矩阵$A$有$n$个线性无关的特征向量$v^{(i)}$，我们可以将所有特征向量连接起来形成一个矩阵$V=[v^{(1)},\\ldots,v^{(n)}]$，并通过连接所有特征值$\\lambda=[\\lambda_1,\\ldots,\\lambda_n]^T$形成一个向量，那么$A$的特征分解是$A=Vdiag(\\lambda)V^{-1}$ 每个实对称矩阵都可以分解为$A=Q\\Lambda Q^T$，其中$Q$是由$A$的特征向量组成的正交矩阵，$\\Lambda$（读作'lambda'）是一个对角矩阵。 拉格朗日乘数法： 拉格朗日乘数法是一种在方程约束下寻找函数局部最大值和最小值的策略。 一般形式：$\\mathcal{L}(x,\\lambda)=f(x)+\\lambda\\cdot g(x)$，$\\lambda$称为拉格朗日乘子。 3 详细PCA推导 需求描述\n我们有$m$个点的输入数据，表示为${x^{(1)},...,x^{(m)}}$在$\\mathbb{R}^{n}$的实数集中。因此，每个点$x^{(i)}$是一个列向量，具有$n$维特征。\n需要对输入数据进行有损压缩，将这些点编码以表示它们的较低维度版本。换句话说，我们想要找到编码向量$c^{(i)}\\in \\mathbb{R}^{l}$，$(l\u0026lt;n)$来表示每个输入点$x^{(i)}$。我们的目标是找到产生输入的编码向量的编码函数$f(x)=c$，以及相应的重构（解码）函数$x\\approx g(f(x))$，根据编码向量$c$计算原始输入。\n解码的$g(f(x))$是一组新的点（变量），因此它与原始$x$是近似的。存储$c^{(i)}$和解码函数比存储$x^{(i)}$更节省空间，因为$c^{(i)}$的维度较低。\n解码矩阵\n我们选择使用矩阵$D$作为解码矩阵，将编码向量$c^{(i)}$映射回$\\mathbb{R}^{n}$，因此$g(c)=Dc$，其中$D\\in \\mathbb{R}^{n\\times l}$。为了简化编码问题，PCA将$D$的列约束为彼此正交。\n衡量重构的表现\n在继续之前，我们需要弄清楚如何生成最优的编码点$c^{}$，我们可以测量输入点$x$与其重构$g(c^)$之间的距离，使用$L^2$范数（或欧几里得范数）：$c^{*}=\\arg\\min_c||x-g(c)||_2$。由于$L^2$范数是非负的，并且平方操作是单调递增的，所以我们可以转而使用平方的$L^2$范数：\n$$c^{*}={\\arg\\min}_c||x-g(c)||_2^2$$ 向量的$L^2$范数是其分量的平方和，它等于向量与自身的点积，例如$||x||_2=\\sqrt{\\sum|x_i|^2}=\\sqrt{x^Tx}$，因此平方的$L^2$范数可以写成以下形式：\n$$||x-g(c)||_2^2 = (x-g(c))^T(x-g(c))$$ 由分配率： $$=(x^T-g(c)^T)(x-g(c))=x^Tx-x^Tg(c)-g(c)^Tx+g(c)^Tg(c)$$ 由于$x^Tg(c)$和$g(c)^Tx$是标量，标量等于其转置，$(g(c)^Tx)^T=x^Tg(c)$，所以： $$=x^Tx-2x^Tg(c)+g(c)^Tg(c)$$ 为了找到使上述函数最小化的$c$，第一项可以省略，因为它不依赖于$c$，所以： $$c^={\\arg\\min}_c-2x^Tg(c)+g(c)^Tg(c)$$ 然后用$g(c)$的定义$Dc$进行替换： $$={\\arg\\min}_c-2x^TDc+c^TD^TDc$$ 由于$D$的正交性和单位范数约束： $$c^={\\arg\\min}_c-2x^TDc+c^TI_lc$$ $$= {\\arg\\min}_c-2x^TDc+c^Tc$$\n目标函数\n现在目标函数是$-2x^TDc+c^Tc$，我们需要找到$c^*$来最小化目标函数。使用向量微积分，并令其导数等于0： $$\\nabla_c(-2x^TDc+c^Tc)=0$$ 根据向量导数规则： $$-2D^Tx+2c=0 \\Rightarrow c=D^Tx$$\n找到编码矩阵 $D$\n所以编码器函数是 $f(x)=D^Tx$。因此我们可以定义 PCA 重构操作为 $r(x)=g(f(x))=D(D^Tx)=DD^Tx$。\n因此编码矩阵 $D$ 也被重构过程使用。我们需要找到最优的 $D$ 来最小化重构误差，即输入和重构之间所有维度特征的距离。这里使用 Frobenius 范数（矩阵范数）定义目标函数： $$D^={\\arg\\min}D\\sqrt{\\sum{i,j}(x_j^{(i)}-r(x^{i})_j)^2},\\quad D^TD=I_l$$\n从考虑 $l=1$ 的情况开始（这也是第一个主成分），$D$ 是一个单一向量 $d$，并使用平方 $L^2$ 范数形式： $$d^={\\arg\\min}d{\\sum{i}||(x^{(i)}-r(x^{i}))}||_2^2, ||d||_2=1$$ $$ = {\\arg\\min}d{\\sum{i}||(x^{(i)}-dd^Tx^{(i)})||_2^2}, ||d||_2=1$$ $d^Tx^{(i)}$ 是一个标量： $$= {\\arg\\min}d{\\sum{i}||(x^{(i)}-d^Tx^{(i)}d)}||_2^2, ||d||_2=1$$\n标量等于其自身的转置：\n$$d^*= {\\arg\\min}d{\\sum{i}||(x^{(i)}-x^{(i)T}dd)}||_2^2, ||d||_2=1$$\n使用矩阵形式表示\n令 $X\\in \\mathbb{R}^{m\\times n}$ 表示所有描述点的向量堆叠，即 ${x^{(1)^T}, x^{(2)^T}, \\ldots, x^{(i)^T}, \\ldots, x^{(m)^T}}$，使得 $X_{i,:}=x^{(i)^T}$。\n$$ X = \\begin{bmatrix} x^{(1)^T}\\ x^{(2)^T}\\ \\ldots\\ x^{(m)^T} \\end{bmatrix} \\Rightarrow Xd = \\begin{bmatrix} x^{(1)^T}d\\ x^{(2)^T}d\\ \\ldots\\ x^{(m)^T}d \\end{bmatrix} $$\n$$ \\Rightarrow Xdd^T = \\begin{bmatrix} x^{(1)^T}dd^T\\ x^{(2)^T}dd^T\\ \\ldots\\ x^{(m)^T}dd^T\\ \\end{bmatrix} $$\n$$ \\Rightarrow X-Xdd^T = \\begin{bmatrix} x^{(1)^T}-x^{(1)^T}dd^T\\ x^{(2)^T}-x^{(2)^T}dd^T\\ \\ldots\\ x^{(m)^T}-x^{(m)^T}dd^T\\ \\end{bmatrix} $$\n矩阵中的一行的转置： $$(x^{(i)^T}-x^{(i)^T}dd^T)^T=x^{(i)}-dd^Tx^{(i)}$$ 由于 $d^Tx^{(i)}$ 是标量： $$=x^{(i)}-d^Tx^{(i)}d=x^{(i)}-x^{(i)^T}dd$$ 所以我们知道 $X$ 的第 $i$ 行的 $L^2$ 范数与原始形式相同，因此我们可以使用矩阵重写问题，并省略求和符号： $$d^={\\arg\\min}{d}||X-Xdd^T||F^2, \\quad d^Td=1 $$ 利用矩阵迹规则简化 Frobenius 范数部分如下： $${\\arg\\min}{d}||X-Xdd^T||F^2$$ $$={\\arg\\min}{d}Tr((X-Xdd^T)^T(X-Xdd^T))$$ $$={\\arg\\min}{d}-Tr(X^TXdd^T)-Tr(dd^TX^TX)+Tr(dd^TX^TXdd^T)$$ $$={\\arg\\min}{d}-2Tr(X^TXdd^T)+Tr(X^TXdd^Tdd^T)$$ 由于 $d^Td=1$： $$={\\arg\\min}{d}-2Tr(X^TXdd^T)+Tr(X^TXdd^T)$$ $$={\\arg\\min}{d}-Tr(X^TXdd^T)$$ $$={\\arg\\max}{d}Tr(X^TXdd^T)$$ 由于迹是循环置换不变的，将方程重写为： $$d^={\\arg\\max}{d}Tr(d^TX^TXd), \\quad d^Td=1$$ 由于 $d^TX^TXd$ 是实数，因此迹符号可以省略： $$d^*={\\arg\\max}{d}d^TX^TXd,\\quad d^Td=1$$\n寻找最优的 $d$\n现在的问题是找到最优的 $d$ 来最大化 $d^TX^TXd$，并且有约束条件 $d^Td=1$。\n使用拉格朗日乘子法来将问题描述为关于 $d$ 的形式： $$\\mathcal{L}(d,\\lambda)=d^TX^TXd+\\lambda(d^Td-1)$$\n对 $d$ 求导数（向量导数规则）： $$\\nabla_d\\mathcal{L}(d,\\lambda)=2X^TXd+2\\lambda d$$\n令导数等于0，$d$ 将是最优的： $$2X^TXd+2\\lambda d=0$$ $$X^TXd=-\\lambda d$$ $$X^TXd=\\lambda' d,\\quad(\\lambda'=-\\lambda)$$\n这个方程是典型的矩阵特征值分解形式，$d$ 是矩阵 $X^TX$ 的特征向量，$\\lambda'$ 是对应的特征值。\n利用上述结果，让我们重新审视原方程： $$d^*={\\arg\\max}{d}d^TX^TXd, \\quad d^Td=1$$ $$={\\arg\\max}{d}d^T\\lambda' d$$ $$={\\arg\\max}{d}\\lambda'd^T d$$ $$={\\arg\\max}{d}\\lambda'$$\n现在问题已经变的非常清楚了，$X^TX$ 的最大特征值会最大化原方程的结果，因此最优的 $d$ 是矩阵 $X^TX$ 对应最大特征值的特征向量。\n这个推导是针对 $l=1$ 的情况，只包含第一个主成分。当 $l\u0026gt;1$ 时，$D=[d_1, d_2, \\ldots]$，第一个主成分 $d_1$ 是矩阵 $X^TX$ 对应最大特征值的特征向量，第二个主成分 $d_2$ 是对应第二大特征值的特征向量，以此类推。\n4 总结 我们有一个数据集，包含 $m$ 个点，记为 ${x^{(1)},...,x^{(m)}}$。 令 $X\\in \\mathbb{R}^{m\\times n}$ 为将所有这些点堆叠而成的矩阵：$[x^{(1)^T}, x^{(2)^T}, \\ldots, x^{(i)^T}, \\ldots, x^{(m)^T}]$。\n主成分分析（PCA）编码函数表示为 $f(x)=D^Tx$，重构函数表示为 $x\\approx g(c)=Dc$，其中 $D=[d_1, d_2, \\ldots]$ 的列是 $X^TX$ 的特征向量，特征向量对应的特征值大小为降序排列。$D^Tx$即是降维度之后的数据。\n后续分析PCA的应用案例文章\n","link":"https://mengwoods.github.io/cn/post/math/003-pca/","section":"post","tags":null,"title":"主成分分析(PCA)的详细推导过程"},{"body":"介绍一些我常用的C++容器和使用方法，以及使用案例。\n1 概述 容器（Container）是一个存储其他对象集合的持有者对象。容器以类模板实现，对支持的元素类型有很大的灵活性。容器管理元素的存储并提供多个成员函数来访问和操作元素。\n两个主要类别：\n序列容器（Sequence container）：将元素维护在线性序列中，通过元素的位置来访问索引某个元素，可以用来存放不需要检索的数据。 关联容器（Associative container）：允许基于键（key）而不是位置进行有效检索（即搜索某个key获取其内容）。通常使用二叉搜索树或哈希表实现。可以用来放置频繁检索的数据。 下面，我将介绍几种常用的序列容器和无序关联容器以及它们的典型用例。\n2 序列容器 Sequence Container 序列容器指的是标准库（STL）中实现数据元素存储的一组容器类模板。包括Array、Vector、List、Forward List、Deque。\nArray：编译时大小不可调整的容器类型。 Vector：具有快速随机访问并在添加元素时自动调整大小的容器类型。 Deque：具有相对较快的随机访问的双端队列。 List：双向链表。 Forward list：单向链表。 2.1 Array std::array 是封装固定大小数组的容器。\n1#include \u0026lt;array\u0026gt; 2// 声明一个包含 3 个元素的整数array 3array\u0026lt;int, 3\u0026gt; arr = {0, 1, 2}; 4// 使用 size() 成员函数获取array的大小 5arr.size(); 6// 使用下标运算符 [] 访问array中索引为 0 的元素 7arr[0]; 2.2 Vector std::vector 是 C++ 标准库中的类模板。它表示可以改变容量大小的序列容器，使用连续的存储位置存储元素。Vector的大小可以动态改变，容器自动处理存储。它动态分配数组以存储元素，与Array相比，Vector消耗更多的内存来管理存储内容。\n1#include \u0026lt;vector\u0026gt; 2// 声明和初始化一个 vector 的方式 3vector\u0026lt;int\u0026gt; vec = {1, 2, 4}; 4vector\u0026lt;int\u0026gt; vec {1, 2, 3}; 5vector\u0026lt;int\u0026gt; vec(4, 3); // 4 是大小，3 是值 {3, 3，3， 3} 6// 将索引为 3 的元素赋值为 5 7vec[3] = 5; 8// 声明一个字符串向量 9vector\u0026lt;string\u0026gt; planets; 10// 向向量中添加字符串 \u0026#34;Mercury\u0026#34; 11planets.push_back(\u0026#34;Mercury\u0026#34;); 12// 检索向量中的元素数量 13planets.size(); 14// 检索向量当前的容量 15planets.capacity(); 3 无序关联容器 Unordered Associative Container 关联容器存储由键值（key）和映射值（map）组合形成的元素。基于键快速检索单个元素。键值通常用于唯一标识元素。\n3.1 无序映射 Unordered Map 无序映射是 C++ 中高效存储键值对而不维护特定顺序的关联容器。它们提供基于键的快速检索、插入和删除操作，适用于需要快速访问由键标识的元素的场景。与有序容器相比，无序映射优先速度而不是元素顺序，提供更快的元素访问。\n1#include \u0026lt;unordered_map\u0026gt; 2// 声明一个具有整数键和值的无序映射 3std::unordered_map\u0026lt;int, int\u0026gt; freq_counter; 4// 访问与键 1 关联的值 5freq_counter[1]; 6// 将一个键值对插入到无序映射中 7freq_counter.insert(std::make_pair(2, 1)); 3.2 无序集合 Unordered Set 无序集合是以无序方式存储一组唯一元素的容器。无序集合不维护其元素之间的特定顺序。它们提供快速的检索、插入和删除操作，通常使用哈希表实现。这使它们适用于需要快速查找唯一元素的场景，而不用担心顺序。\n1#include \u0026lt;unordered_set\u0026gt; 2// 声明并初始化一个包含整数元素的无序集合 3std::unordered_set\u0026lt;int\u0026gt; mySet{2, 7, 1, 8, 2, 8}; 4// 向无序集合中插入值 5 5mySet.insert(5); 6// 如果存在，从无序集合中删除值 5 7mySet.erase(5); 3.3 应用场景 需求描述\n工作中遇到的一个使用案例： 设计一个目标车辆速度管理系统，旨在存储和调节交通车辆（障碍物）的速度。如果检测到车辆的速度大小不确定，系统将检索并应用上次该目标已知的速度大小以及其当前的速度方向。目的是维持交通上目标车辆的速度幅度稳定程度，尽量减少速度的突然变化，来弥补感知系统中Tracker自身的不足，因为如果某个车辆突然转向或突然出现到场景中，其速度可信程度不高。\n代码片段示例\n1// 初始化用于存储障碍物对象和障碍物 ID 的关联容器 2std::unordered_map\u0026lt;int, Eigen::Vector3d\u0026gt; obstacles_; 3std::unordered_set\u0026lt;int\u0026gt; obstacle_ids_; 4 5// 添加障碍物信息 6obstacle_ids_.insert(id); 7obstacles_[id] = velocity; 8 9// 从容器中移除障碍物 10obstacles_.erase(id); 11obstacle_ids_.erase(id); 12 13// 获取最后的速度 14auto it = obstacles_.find(id); 15// 如果找到 ID，则返回速度 16if (it != obstacles_.end()) 17{ 18 return it-\u0026gt;second; 19} 20else 21{ 22 // 如果未找到，则返回零速度 23} 24 25// 移除不再需要的障碍物 ID 26std::unordered_set\u0026lt;int\u0026gt; ids_to_remove; 27for (const auto\u0026amp; obstacle : obstacles_) 28{ 29 int id = obstacle.first; 30 if (obstacle_ids_.find(id) == obstacle_ids_.end()) 31 { 32 ids_to_remove.insert(id); 33 } 34} 35for (int id_to_remove : ids_to_remove) 36{ 37 obstacles_.erase(id_to_remove); 38} 39 40// 清除信息 41obstacle_ids_.clear(); 42 43// 使用最后速度的大小以及当前方向 44double magnitude = last_velocity.norm(); 45// 将当前速度归一化以保持其方向 46if (current_velocity.norm() \u0026gt; 0.0) // 避免除以零 47{ 48 current_velocity.normalize(); 49} 50else 51{ 52 // 如果当前速度为零，直接返回它 53 return current_velocity; 54} 55// 将归一化后的当前速度按照最后速度的大小进行缩放 56current_velocity *= magnitude; 57// 得到所需的速度 58return current_velocity; 4 LeetCode 题 3005 Count Elements With Maximum Frequency\nYou are given an array nums consisting of positive integers. Return the total frequencies of elements in nums such that those elements all have the maximum frequency. The frequency of an element is the number of occurrences of that element in the array.\nExample 1:\nInput: nums = [1,2,2,3,1,4] Output: 4 Explanation: The elements 1 and 2 have a frequency of 2 which is the maximum frequency in the array. So the number of elements in the array with maximum frequency is 4.\nExample 2:\nInput: nums = [1,2,3,4,5] Output: 5 Explanation: All elements of the array have a frequency of 1 which is the maximum. So the number of elements in the array with maximum frequency is 5. Constraints: 1 \u0026lt;= nums.length \u0026lt;= 100 1 \u0026lt;= nums[i] \u0026lt;= 100\n4.1 使用 Vector code file\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;vector\u0026gt; 3 4using namespace std; 5 6class Solution 7{ 8public: 9 int maxFrequencyElements(vector\u0026lt;int\u0026gt;\u0026amp; nums) 10 { 11 vector\u0026lt;int\u0026gt; frequency (nums.size(), 0); 12 for (int i = 0; i \u0026lt; frequency.size(); i ++) 13 { 14 frequency[i] = countDuplicatedNumber(i, nums); 15 } 16 for (int element : frequency) 17 { 18 std::cout \u0026lt;\u0026lt; element \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 19 } 20 cout \u0026lt;\u0026lt; endl; 21 int max_value = checkMaxValue(frequency); 22 return sumMaxValue(max_value, frequency); 23 } 24 int countDuplicatedNumber(const int\u0026amp; index, const vector\u0026lt;int\u0026gt;\u0026amp; vector) 25 { 26 int number = 1; 27 for (int i = 1; i + index \u0026lt; vector.size(); i++) 28 { 29 if (vector[i + index] == vector[index]) 30 { 31 number ++; 32 } 33 } 34 return number; 35 } 36 int checkMaxValue(const vector\u0026lt;int\u0026gt;\u0026amp; vector) 37 { 38 int max = 0; 39 for (int i = 0; i \u0026lt; vector.size(); i++) 40 { 41 if (vector[i] \u0026gt; max) 42 { 43 max = vector[i]; 44 } 45 } 46 cout \u0026lt;\u0026lt; \u0026#34;max value in the vec is: \u0026#34; \u0026lt;\u0026lt; max \u0026lt;\u0026lt; endl; 47 return max; 48 } 49 int sumMaxValue(const int\u0026amp; max, const vector\u0026lt;int\u0026gt;\u0026amp; vector) 50 { 51 int sum = 0; 52 for (int i = 0; i \u0026lt; vector.size(); i++) 53 { 54 if (vector[i] == max) 55 { 56 sum += vector[i]; 57 } 58 } 59 return sum; 60 } 61}; 62 63int main() 64{ 65 vector\u0026lt;int\u0026gt; num1 {1,2,2,3,4,4,1}; 66 Solution solution; 67 float result = solution.maxFrequencyElements(num1); 68 cout \u0026lt;\u0026lt; \u0026#34;result is: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; 69} 4.1 使用 Unnordered map code file, [reference]\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;vector\u0026gt; 3#include \u0026lt;unordered_map\u0026gt; 4 5using namespace std; 6 7class Solution 8{ 9public: 10 int maxFrequencyElements(vector\u0026lt;int\u0026gt;\u0026amp; nums) 11 { 12 std::unordered_map\u0026lt;int, int\u0026gt; freq_counter; 13 for(int num : nums) 14 { 15 freq_counter[num]++; 16 } 17 18 int max_frequency = 0; 19 for (const auto\u0026amp; entry : freq_counter) 20 { 21 max_frequency = std::max(max_frequency, entry.second); 22 } 23 24 int max_freq_elements = 0; 25 for (const auto\u0026amp; entry : freq_counter) 26 { 27 if (entry.second == max_frequency) 28 { 29 max_freq_elements++; 30 } 31 } 32 33 int total_frequency = max_frequency * max_freq_elements; 34 return total_frequency; 35 } 36}; 37 38int main() 39{ 40 vector\u0026lt;int\u0026gt; num1 {7,7,7,1,2,2,3,4,4,1}; 41 Solution solution; 42 int result = solution.maxFrequencyElements(num1); 43 cout \u0026lt;\u0026lt; \u0026#34;result is: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; 44} ","link":"https://mengwoods.github.io/cn/post/code/002-c++-containers/","section":"post","tags":null,"title":"C++ 常用容器以及一些应用案例"},{"body":"向量点乘，叉乘的概念，以及他们的应用及相关C++代码的实现。\n1 向量 向量具有大小和方向。 共线向量：两个平行的向量为共线向量。\n1.1 叉积 Cross Product $$\\vec{a}\\times\\vec{b}=|\\vec{a}||\\vec{b}|\\sin{\\theta}\\vec{n}$$\n$\\theta$是两个向量之间的角度，$\\vec{n}$是与两个向量都垂直的单位向量，方向遵循右手定则（右手食指从$\\vec{a}$划到$\\vec{b}$，大拇指的方向）。\n两个向量的叉积结果是一个与两者都垂直的向量。叉积的幅度值大小等于由这两个向量为边组成的平行四边形的面积。当两个向量垂直时，大小也达到最大，及矩形的面积。（这个特性决定了他可以用来计算空间中一个点到一个直线的距离，利用几何中平行四边形的面积同时等于底乘高，后面会介绍。）\n三维空间中，叉积的结果也可以用3x3矩阵的行列式表示。\n$$ \\vec{a}\\times \\vec{b}=\\det(\\vec{i},\\vec{j},\\vec{k};a_1,a_2,a_3;b_1,b_2,b_3)\\ =(a_2b_3 - a_3,b_2)\\vec{i}+(a_3b_1 - a_1,b_3)\\vec{j}+(a_1b_2 - a_2,b_1)\\vec{k}$$\n1.2 点积 Dot Product 叉积给出一个向量结果，但点积给出一个标量结果。 它将向量的相同方向投影的的长度相乘，因此使用$\\cos{\\theta}$将其中一个向量投影到另一个上。所以如果两个向量成直角，那么结果为零。点积更容易理解一些。\n$$ \\vec{a}\\cdot \\vec{b} = |\\vec{a}||\\vec{b}|\\cos{\\theta} $$\n2 实际应用 判断两个向量是否：\n共线：$\\vec{A}$=k*$\\vec{B}$，其中k是一个标量；叉积是零向量（仅适用于三维空间）；对应坐标的比率相等。 垂直：点积为零。 计算点P在线段AB上的投影点C坐标。\n向量$\\vec{AB}$，$\\vec{AP}$，点积结果为D。$\\vec{AB} \\cdot \\vec{AP}=D$ 推导一下：$\\vec{AB} \\cdot \\vec{AP}=|\\vec{AB}| |\\vec{AP}| \\cos{\\theta}=|\\vec{AC}| |\\vec{AB}| = D$ -\u0026gt; $D/|\\vec{AB}| = |\\vec{AC}|$ 求比率：$k = |\\vec{AC}|/|\\vec{AB}| = D/{|\\vec{AB}|^2}$ 最终坐标根据$A$和$k$可以求得：$C = A + k\\vec{AB}$ 如何验证C是投影点：\n验证其共线性：$\\vec{AC} = k \\vec{AB}$或$\\vec{AC} \\times \\vec{AB}=\\vec{0}$ 验证垂直：$\\vec{PC}\\cdot \\vec{AB} = 0$ 如何计算点P到线AB的距离d\n叉积的范数是由两个向量张成的平行四边形的面积$（\\vec{AB} \\times \\vec{AP}）$ 基于几何原理，这个面积也等于距离（高）乘以边长 $d * |\\vec{AB}|$ 所以$d = |\\vec{AB} \\times \\vec{AP}|/|\\vec{AB}|$ 3 代码实现 第一个版本代码，不用额外的库，手搓一些Utility函数，透彻了解原理：\n1#include\u0026lt;iostream\u0026gt; 2#include\u0026lt;cmath\u0026gt; 3using namespace std; 4 5struct Point 6{ 7 double x, y, z; 8 // Overloading the multiplication operator 9 Point operator*(double k) const 10 { 11 return {k*x, k*y, k*z}; 12 } 13 Point operator+(Point A) const 14 { 15 return {A.x + x, A.y + y, A.z + z}; 16 } 17 bool operator==(Point A) const 18 { 19 if (A.x == x and A.y == y and A.z == z) 20 { 21 return true; 22 } 23 else 24 { 25 return false; 26 } 27 } 28}; 29 30double dotProduct(Point A, Point B) 31{ 32 return A.x * B.x + A.y * B.y + A.z * B.z; 33} 34 35Point crossProduct(Point A, Point B) 36{ 37 return {A.y * B.z - A.z * B.y, 38 A.x * B.z - A.z * B.x, 39 A.x * B.y - A.y * B.x}; 40} 41 42float calcNorm(Point A) 43{ 44 return sqrt(A.x * A.x + A.y * A.y + A.z * A.z); 45} 46 47Point calcProjection(Point A, Point B, Point P) 48{ 49 Point AB = {B.x - A.x, B.y - A.y, B.z - A.z}; 50 Point AP = {P.x - A.x, P.y - A.y, P.z - A.z}; 51 double dot_product = dotProduct(AB, AP); 52 double k = dot_product / dotProduct(AB, AB); 53 Point C = A + (AB * k); 54 return C; 55} 56 57bool verifyProjection(Point A, Point B, Point P, Point C) 58{ 59 Point AC = {C.x - A.x, C.y - A.y, C.z - A.z}; 60 Point AB = {B.x - A.x, B.y - A.y, B.z - A.z}; 61 Point PC = {C.x - P.x, C.y - P.y, C.z - P.z}; 62 double dot_product = dotProduct(PC, AB); 63 Point cross_product = crossProduct(AC, AB); 64 Point zero_vec = {0, 0, 0}; 65 if (dot_product == 0 and cross_product == zero_vec) 66 { 67 return true; 68 } 69 else 70 { 71 return false; 72 } 73} 74 75float calcDistance(Point A, Point B, Point P) 76{ 77 Point AB = {B.x - A.x, B.y - A.y, B.z - A.z}; 78 Point AP = {P.x - A.x, P.y - A.y, P.z - A.z}; 79 Point cross_product = crossProduct(AB, AP); 80 float area_parallelogram = calcNorm(cross_product); 81 return (area_parallelogram / calcNorm(AB)); 82} 83 84int main() 85{ 86 // Line segment AB 87 Point A = {0, 0, 0}; 88 Point B = {4, 0, 0}; 89 // Point P 90 Point P = {5, 8, 0}; 91 // Project P to AB and get point C 92 Point C = calcProjection(A, B, P); 93 cout \u0026lt;\u0026lt; \u0026#34;Projection Point C: (\u0026#34; \u0026lt;\u0026lt; C.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; C.y \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; C.z \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; endl; 94 if (verifyProjection(A, B, P, C)) 95 { 96 cout \u0026lt;\u0026lt; \u0026#34;Correct!\u0026#34; \u0026lt;\u0026lt; endl; 97 } 98 else 99 { 100 cout \u0026lt;\u0026lt; \u0026#34;Incorrect.\u0026#34; \u0026lt;\u0026lt; endl; 101 } 102 cout \u0026lt;\u0026lt; \u0026#34;Distance from P to AB is: \u0026#34; \u0026lt;\u0026lt; calcDistance(A, B, P) \u0026lt;\u0026lt; endl; 103 return 0; 104} 另外一个版本，通过使用Eigen库来避免自己写Utility函数，行数大大减少（君子生非异也，善假于物也。）：\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;Eigen/Dense\u0026gt; 3using namespace std; 4using namespace Eigen; 5 6Vector3d calcProjection(Vector3d A, Vector3d B, Vector3d P) 7{ 8 Vector3d AB = B - A; 9 Vector3d AP = P - A; 10 float AC_norm = AB.dot(AP) / AB.norm(); 11 Vector3d C = A + AC_norm / AB.norm() * AB; 12 return C; 13} 14 15bool verifyProjection(Vector3d A, Vector3d B, Vector3d P, Vector3d C) 16{ 17 Vector3d AB = B - A; 18 Vector3d PC = P - C; 19 Vector3d AC = C - A; 20 Vector3d zero_vec = {0, 0, 0}; 21 Vector3d cross_product = AB.cross(AC); 22 float dot_product = PC.dot(AB); 23 if (dot_product == 0 and cross_product == zero_vec) 24 { 25 return true; 26 } 27 else 28 { 29 return false; 30 } 31} 32 33float calcDistance(const Vector3d A, const Vector3d B, const Vector3d P) 34{ 35 Vector3d AB = B - A; 36 Vector3d AP = P - A; 37 Vector3d cross_product = AB.cross(AP); 38 float area_parallelogram = cross_product.norm(); 39 return area_parallelogram / AB.norm(); 40} 41 42int main() 43{ 44 Eigen::Vector3d A = {0, 0, 0}; 45 Eigen::Vector3d B = {2, 0, 0}; 46 Eigen::Vector3d P = {1, 3, 0}; 47 48 Vector3d C = calcProjection(A, B, P); 49 cout \u0026lt;\u0026lt; \u0026#34;Projection point is: \u0026#34; \u0026lt;\u0026lt; C.x() \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; C.y() \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; C.z() \u0026lt;\u0026lt; endl; 50 if (verifyProjection(A, B, P, C)) 51 { 52 cout \u0026lt;\u0026lt; \u0026#34;Verification passes!\u0026#34; \u0026lt;\u0026lt; endl; 53 } 54 else 55 { 56 cout \u0026lt;\u0026lt; \u0026#34;Verification failed.\u0026#34; \u0026lt;\u0026lt; endl; 57 } 58 cout \u0026lt;\u0026lt; \u0026#34;Distance from P to AB is: \u0026#34; \u0026lt;\u0026lt; calcDistance(A, B, P) \u0026lt;\u0026lt; endl; 59} 有问题欢迎一起评论交流，我会回复或更新文章，谢谢！\n上述步骤的代码源文件：\n原始实现 使用Eigen库的实现 ","link":"https://mengwoods.github.io/cn/post/math/001-vector-cross-product/","section":"post","tags":null,"title":"向量点乘与叉乘"},{"body":"本文收集了一些有用的Docker命令。\n0. 基本概念和命令 Docker容器和Docker镜像\nDocker container 是Docker镜像的运行实例，提供了一个可以启动、停止和删除的独立环境。 Docker image 是一个静态、只读文件，包含创建容器所需的一切内容。它是启动Docker容器的源文件。\n基本Docker命令\n1# 通过镜像名拉取Docker镜像 2docker pull \u0026lt;镜像名称\u0026gt; 3 4# 列出本地可用的Docker镜像（镜像ID） 5docker images 6# 列出当前正在运行的Docker容器（容器ID） 7docker ps 8# 列出当前正在运行的Docker容器，包括已停止的容器 9docker ps -a 10 11# 查看特定容器的日志 12docker logs \u0026lt;容器ID\u0026gt; 13# 停止运行中的容器 14docker stop \u0026lt;容器ID\u0026gt; 15 16# 通过镜像ID在本地删除Docker镜像 17docker rmi \u0026lt;镜像ID\u0026gt; 18 19# 在`docker-compose.yml`文件中启动容器（使用-d以进行分离模式） 20docker-compose up 21# 在`docker-compose.yml`文件中停止容器 22docker-compose down 查看基本Docker信息 查看用户名和Docker镜像库：\n1docker system info | grep -E \u0026#39;Username|Registry\u0026#39; 1. 其他实用的命令 将镜像保存到.tar文件。\n首先使用docker images命令来查看您想要保存的镜像ID，然后使用以下命令进行保存：\n1docker save -o /path/to/\u0026lt;filename\u0026gt;.tar image-id image-id可以替换为REPOSITORY:TAG格式。为了更清晰的文件名，建议使用REPOSITORY:TAG格式命名文件。\n从.tar文件加载Docker镜像\n1docker load -i /path/to/filename.tar 重新标记Docker镜像\n1docker tag \u0026lt;source-repository:tag\u0026gt; \u0026lt;new-repository:tag\u0026gt; 一次性停止所有正在运行的Docker容器。\n往往在后台运行多个容器。如果不检查，很难意识到它们正在运行。要一次性停止它们，使用以下命令。该命令较为常用，建议设置为alias。\n1docker stop $(docker ps -a -q) 删除所有Docker镜像。\nDocker镜像会占用存储空间。要从系统中删除所有镜像，使用以下命令：\n1docker rmi $(docker images -q) 删除具有多个标签的同名镜像。\n如果要删除特定仓库中具有不同标签的所有镜像，请使用以下脚本。\n首先使用docker images命令来查看要删除的镜像。输出如下所示：\n1REPOSITORY TAG IMAGE ID CREATED SIZE 2registry-A 0.0.1 xxxx 25 hours ago 7.5GB 3registry-A 0.0.2 xxxx 25 hours ago 7.5GB 4registry-A 0.1.0 xxxx 25 hours ago 7.5GB 5... ... ... ... ... 在这种情况下，需要删除来自仓库registry-A的所有镜像。将下面的脚本保存到一个文件中，例如remove_tags.sh。\n1 #!/bin/bash 2 3 read -p \u0026#34;Enter the name of the repository: \u0026#34; REPOSITORY 4 5 # Get all tags for the repository (exclude headers) 6 tags=$(docker images --format \u0026#34;{{.Tag}}\u0026#34; $REPOSITORY) 7 8 # Loop through each tag and remove the corresponding image 9 for tag in $tags; do 10 docker rmi $REPOSITORY:$tag 11 echo \u0026#34;$REPOSITORY:$tag removed\u0026#34; 12 done 要使用它，在终端中运行bash remove_tags.sh，然后在提示时提供仓库名称。在此示例中是registry-A。此脚本将逐个删除指定仓库的所有标签镜像。\n","link":"https://mengwoods.github.io/cn/post/tech/003-some-docker-commands/cn/","section":"post","tags":null,"title":"一些实用的Docker命令"},{"body":"Dockerfile, Conda\n使用常规方法创建Conda虚拟环境并激活的过程会遇到很多错误，经过查找资料，总结了可行的方法。本文方法的参考文章。\n1. 保存虚拟环境yml文件 在本地激活你想放入Docker中的Conda虚拟环境：conda activate \u0026lt;myenv\u0026gt;。 输出Conda环境配置文件：conda env export \u0026gt; environment.yml。 删除配置文件中位于pip之后的内容。 在我的Docker生成过程中，环境配置文件中若包含pip安装包，则会报错。所以需要删除相关的包，在Dockerfile中，可以在conda环境激活后重新使用pip手动安装所需的。 下面是一个典型的environment.yml文件： 1name: myenv 2channels: 3 - pytorch 4 - nvidia 5 - ... 6dependencies: 7 - _libgcc_mutex=0.1=main 8 - blas=1.0=mkl 9 - ... 10- pip: # 删除此行及以下的内容并保存文件 11 - addict==2.4.0 12 - aliyun-python-sdk-core==2.14.0 13 - ... 14prefix: /home/*/miniconda3/envs/myenv 2. 编写Dockerfile 在你的Dockerfile中添加如下内容：\n1# 使用带有conda的镜像 2FROM continuumio/miniconda3 3 4WORKDIR /app 5 6# 使用上一节的环境文件创建虚拟环境: 7COPY environment.yml . 8RUN conda env create -f environment.yml 9 10# 激活该虚拟环境: 11SHELL [\u0026#34;conda\u0026#34;, \u0026#34;run\u0026#34;, \u0026#34;-n\u0026#34;, \u0026#34;\u0026lt;myenv\u0026gt;\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;] 12 13# 若需要安装pip包，如下： 14RUN pip install A B C 通过该Dockerfile则可以构建使用Conda虚拟环境的镜像。\n","link":"https://mengwoods.github.io/cn/post/tech/002-run-conda-in-dockerfile/","section":"post","tags":null,"title":"在Docker中使用conda虚拟环境"},{"body":"准备 本安装在以下环境中进行了测试：Ubuntu 20.04、CUDA-11.6、PyTorch v1.13.1。\nMiniconda 此安装在conda虚拟环境中进行，因此请确保已安装Miniconda。\nLinux下安装：\n1mkdir -p ~/miniconda3 2wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh 3bash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3 4rm -rf ~/miniconda3/miniconda.sh 初始化：\n1~/miniconda3/bin/conda init bash 2~/miniconda3/bin/conda init zsh CUDA Toolkit 本问建议使用CUDA 11.6和Nvidia驱动程序510.39.01。Nvidia驱动程序可以与CUDA一起安装。\n检查CUDA版本：nvcc --version 从系统中删除CUDA：sudo /usr/local/cuda-11.x/bin/cuda-uninstaller（将x替换为CUDA的版本） 检查Nvidia驱动程序版本：nvidia-smi 删除Nvidia驱动程序：sudo /usr/bin/nvidia-uninstall 安装CUDA11.6和驱动程序510.39.01：\n1wget https://developer.download.nvidia.com/compute/cuda/11.6.0/local_installers/cuda_11.6.0_510.39.01_linux.run 2sudo sh cuda_11.6.0_510.39.01_linux.run 在终端中勾选Nvidia驱动程序。\n若需要安装其他版本，请查看官方网站。\n安装依赖 创建一个虚拟环境：\n1conda create --name openmmlab python=3.8 -y 2conda activate openmmlab 安装PyTorch v1.13.1：\n1conda install pytorch==1.13.1 torchvision==0.14.1 torchaudio==0.13.1 pytorch-cuda=11.6 -c pytorch -c nvidia 安装SpConv：\n1pip install spconv-cu116 安装MMDetection3D 了解更多信息：https://mmdetection3d.readthedocs.io/en/latest/get_started.html\n安装MM相关依赖 1# 安装mim 2pip install -U openmim 3mim install mmengine \u0026#39;mmcv\u0026gt;=2.0.0rc4\u0026#39; \u0026#39;mmdet\u0026gt;=3.0.0\u0026#39; 安装MMDetection3D库 情况一: 使用该库作为一个第三方包：\n1# 安装mmdet3d 2mim install \u0026#34;mmdet3d\u0026gt;=1.1.0\u0026#34; 情况二：以源码方式安装：\n1git clone https://github.com/open-mmlab/mmdetection3d.git -b dev-1.x 2cd mmdetection3d 3pip install -v -e . 测试 要测试结果，请在Python环境中尝试从中导入库，例如：\n1from mmdet3d.apis import init_model, inference_detector 或者\n1import mmdet3d 2print(mmdet3d.__version__) ","link":"https://mengwoods.github.io/cn/post/tech/001-install-openmm3d-lib/cn/","section":"post","tags":null,"title":"MMDetection3D库的安装指导"},{"body":"安装Hugo 在Github releases页面下载安装最新版本。 例如下载*.deb文件然后使用dpkg -i *.deb安装。\n或者使用官方文档安装：【安装方法】\n第一步：创建所需Repo 在Github创建两个Repo，创建时皆勾选Add a README file选项：\nBlog源文件仓库：存储网页源文件，用于生成博客网站。（参考命名：blog-resources） Pages仓库：用于保存所生成的网页文件，并可通过网址进入博客。（命名需按照：\u0026lt;username\u0026gt;.github.io，其中\u0026lt;username\u0026gt;为Github账户名。【官方说明】） 第二步：使用Hugo命令创建博客文件 源文件仓库名以blog-resources为例。\n克隆blog-resources到本地。 进入blog-resources路径中，使用Hugo命令创建网站整体文件夹结构hugo new site \u0026lt;blog-name\u0026gt;，替换\u0026lt;blog-name\u0026gt;为你需要的，例如woods-blog。 此时repo文件结构以及它们的主要用途如下： 1├── README.md # 创建Repo时自动天剑的README 2└── woods-blog # 博客文件夹名，与上一步使用hugo创建的一致 3 ├── archetypes 4 ├── config.toml # 博客网站自定义配置文件，需要进一步编辑 5 ├── content # 博客内容文件夹，存放博客文档，图片等 6 ├── data 7 ├── layouts 8 ├── resources 9 ├── static 10 └── themes # 主题文件夹，需要进一步安装Hugo主题 第三步：添加主题文件并配置 浏览Hugo主题并选择。 主题介绍部分一般带有安装方法，可以按照该方法进行安装。但我在安装一些主题过程中总遇到错误。此处以我选择的主题Mainroad进行介绍。 进入博客文件路径blog-resources/woods-blog，以git submodule方式添加主题文件。 1git submodule add https://github.com/vimux/mainroad.git themes/mainroad 若添加成功，此时在blog-resources/woods-blog/themes下会出现该主题文件名为Mainroad。 1└── themes 2 └── Mainroad # 此处为所安装的主题名 在blog-resources/woods-blog/themes/Mainroad/exampleSite中，复制文件夹content，static，和文件config.toml到blog-resources/woods-blog下，并覆盖原有文件。 配置blog-resources/woods-blog/config.toml文件，主要需要查看的关键词如下： 1# 确认url为所创建Pages Repo网址，其形式如下，结尾带`/` 2baseurl = \u0026#34;https://\u0026lt;username\u0026gt;.github.io/\u0026#34; 3# Theme 为所安装的主题名字 4theme = \u0026#34;mainroad\u0026#34; 第四步：测试博客并发布为HTML 启动Hugo server：hugo server，登录网址http://localhost:1313/预览博客主题。 若需要添加博客文档，可在blog-resources/woods-blog/content下创建新的.md文档进行测试，Hugo server会实时更新以预览。 发布博客为HTML网页，在blog-resources/woods-blog/路径下使用命令hugo。 若发布成功，此时在路径blog-resources/woods-blog/下会多一个文件夹public用于保存HTML网页文件。 第五步：将HTML文件推送到Pages仓库 进入blog-resources/woods-blog/public路径，将该文件夹设置为Pages仓库：\n1# 初始化为新的Git仓库 2git init 3# 创建main分支 4git checkout -b \u0026#39;main\u0026#39; 5# 将Pages仓库的SSH添加为到本地 6git remote add origin git@github.com:\u0026lt;username\u0026gt;/\u0026lt;username\u0026gt;.github.io.git 推送本地文件到仓库：\n1# 同步本地与远端的commits 2git pull --rebase origin main 3# 添加本地所有的改变 4git add . 5# 添加commit以及相关描述信息 6git commit -m \u0026#34;commit information, e.g. add blog template\u0026#34; 7# 推送到远端仓库 8git push origin main 浏览器键入网址以浏览博客https://\u0026lt;username\u0026gt;.github.io/，可能需要等待几分钟。\n后续 推送blog-resources仓库至Github。\n参考 如何用 GitHub Pages + Hugo 搭建个人博客。 ","link":"https://mengwoods.github.io/cn/post/tech/000-build-hugo-site/en/","section":"post","tags":["Hugo"],"title":"使用Hugo搭建个人博客"},{"body":"","link":"https://mengwoods.github.io/cn/","section":"","tags":null,"title":"Menghao blog"},{"body":"","link":"https://mengwoods.github.io/cn/post/","section":"post","tags":null,"title":"Posts"},{"body":"","link":"https://mengwoods.github.io/cn/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://mengwoods.github.io/cn/categories/hobby/","section":"categories","tags":null,"title":"Hobby"},{"body":"","link":"https://mengwoods.github.io/cn/categories/wechat/","section":"categories","tags":null,"title":"Wechat"},{"body":"","link":"https://mengwoods.github.io/cn/categories/dl/","section":"categories","tags":null,"title":"DL"},{"body":"","link":"https://mengwoods.github.io/cn/categories/math/","section":"categories","tags":null,"title":"Math"},{"body":"","link":"https://mengwoods.github.io/cn/categories/code/","section":"categories","tags":null,"title":"Code"},{"body":"简介 《谷物大脑》（Grain Brain）【豆瓣】一书由美国神经科医生、营养学家 David Perlmutter 撰写。该书主要观点为食物中的麸质（Gluten）以及过量的碳水化合物会对身体造成持久的损害，二者也是间接导致糖尿病以及阿尔兹海默症的诱因；而食用健康的脂肪、蛋白质、维生素等则对身体及大脑健康有益。作者在饮食方面的建议是减少对谷物的摄入，食用无麸质食物，降低每日碳水化合物食品摄入，提高肉、蛋、蔬菜等摄入。\n何为麸质？ 麸质是一类蛋白质，存在与许多谷物中，如大麦、小麦、燕麦等。其负责提供面类食物的韧性和弹性，我们所熟知的面筋就是麸质，完全由麸质构成的食品主要有辣条、牛筋面等。麸质蛋白与其他蛋白质不同，人类肠道无法正常消化它，而且其容易粘到小肠壁上造成一些健康问题，部分人对麸质会产生直接过敏反应。面类食品中广泛含有麸质，如面包、披萨、意大利面、面条、包子饺子等。即有面的地方就有麸质，除非原材料是去麸质处理过的。\n有关碳水化合物 碳水化合物（carbohydrate）主要指糖类食物，可以为身体提供能量。淀粉是食物中常见的糖，谷物、根茎类食物含有大量淀粉，部分蔬菜中也含有少量淀粉。水果中含有果糖葡萄糖等，这些都会提高血糖从而为身体提供能量。\n在看食物碳水化合物比例时，还要同时注意其升糖指数（glycemic index， GI），其度量食物在体内的升糖能力。尽管一些蔬菜中含有淀粉，但由于其被纤维所包围，在体内会被缓慢地消化，所以其GI相比较米饭而言是较低的。米饭面包等食物中的淀粉则会被迅速地消化，具有较高的GI。低GI食物对身体有益，而长期食用高GI食物则会对身体造成一些问题。一个有趣的点是即使是同样的食物，不同的烹饪形式也会影响其GI，相比热腾腾的米饭而言，冷的寿司就具有较低的GI，因为冷的寿司在胃里会消化更久。\n摒弃的食物 含有麸质食物：面类食品（面包、面条、意大利面、糕点、麦片、披萨、包子、饺子、油条等），含有麸质的调料：大豆酱油等。 不健康的油类：人造黄油、植物起酥油以及任何商业品牌的食用油（大豆油、玉米油、棉籽油、油菜籽油、花生油、红花籽油、葡萄籽油、葵花籽油、稻糠油还有小麦胚芽油） 加工过的含糖食物：薯片、饼干、曲奇饼、糕点、松饼、比萨面团、蛋糕、甜甜圈、含糖的零食、糖果、能量棒、冰激凌/冷冻酸奶冰激凌/果汁牛奶冻、果酱/果冻/蜜饯、西红柿酱、涂抹型再制干酪、果汁、果干、运动饮料、软饮料/汽水、油炸食品、蜂蜜、龙舌兰、糖（白糖和红糖）、玉米糖浆以及枫树糖浆。 淀粉食物：玉米、山药、土豆、红薯（我感觉这些应该属于少量吃的一组） 非发酵的大豆（如豆腐和豆浆）和加工过的大豆制品（请查找成分列表中有“大豆分离蛋白”的食品；避免大豆奶酪、大豆汉堡包、大豆热狗、大豆鸡块、大豆冰激凌、大豆酸奶）。请注意：虽然一些自然酿造酱油中理应不含麸质，但是许多商业品牌的酱油中有微量麸质。如果你在烹饪中需要使用酱油，那么请选择用100%大豆酿造不含小麦成分的酱油。 个人感觉淀粉类食物应该输入少量食用的一类。而关于非发酵的大豆类，我并不懂其原因。\n需要的食物 健康的油脂：特级初榨橄榄油、芝麻油、椰子油、草饲牛油和有机或者牧场黄油、印度酥油、杏仁乳、鳄梨、椰子、橄榄、坚果和坚果酱、奶酪（除了蓝纹奶酪之外）以及部分种子〔亚麻籽、葵花籽、南瓜籽、芝麻、奇异籽(Chia Seeds)〕。（注：花生不属于坚果） 蛋白质：全蛋，野生鱼类〔三文鱼、裸盖鱼(Black Cod)、鲯鳅鱼(Mahi Mahi)、石斑鱼(Grouper)、鲱鱼(Herring)、鳟鱼(Trout)、沙丁鱼〕贝类以及软体动物（虾、蟹、龙虾、贻贝、蛤、牡蛎），草饲肉、禽类以及猪肉（牛肉、羊肉、肝脏、野牛肉、鸡肉、火鸡肉、鸭肉、鸵鸟肉、小牛肉），野味。 蔬菜：绿叶蔬菜和莴苣、羽衣甘蓝、菠菜、西兰花、甜菜、卷心菜、洋葱、蘑菇、花椰菜、抱子甘蓝、（酸）泡菜、朝鲜蓟、苜蓿芽(Alfalfa Sprouts)、青刀豆、芹菜、小白菜(Bok Choy)、小红萝卜、豆瓣菜(Watercress)、萝卜(Turnip)、芦笋、大蒜、韭菜、茴香、青葱、葱、姜、豆薯(Jicama)、欧芹、荸荠。 低糖水果：鳄梨、灯笼椒、黄瓜、西红柿、西葫芦、笋瓜(Squash)、南瓜、茄子、柠檬、酸橙。 药草、调料和佐料：只要你仔细查看了标签，那么你可以随意使用调料和佐料。吻别西红柿酱和酸辣酱吧，开始享用芥末酱、辣根酱(Horseradish)、橄榄酱(Tapenade)、墨西哥辣椒酱(Salsa)，不过必须是其中不含麸质、小麦、大豆和糖的酱料。对药草和调料基本没有限制，但是请留意包装的产品，因为出产该产品的工厂可能也加工小麦和大豆。 鸡蛋：鸡蛋非常健康，可以作为早餐或者零食，可以多吃。 适当食用的食物 一天一次使用少量，或者理想情况下每星期使用几次：\n不含麸质的谷物：苋菜、荞麦、大米（糙米、白米、野生米）、小米、藜麦(Quinoa)、高粱、画眉草。（关于燕麦的注解：虽然燕麦本身不含麸质，但是因为加工燕麦的磨坊也加工小麦而经常会使燕麦中混有麸质，除非是保证不含麸质的燕麦，否则请避免使用燕麦。）不含麸质的谷物在为了人类食用而进行加工的过程中（例如，整粒燕麦的研磨还有大米包装前的加工），谷物的物理结构方式改变，这会增加炎症反应的风险。出于这一原因，我们要限制这些食品。 豆类：（豆子、小扁豆和豌豆）。例外：你可以吃鹰嘴豆泥（由鹰嘴豆制成）。 蔬菜：胡萝卜和欧防风(Parsnips)。 甜的水果（整果）：浆果最佳，要格外当心含糖的水果，比如杏、芒果、甜瓜、木瓜、李子和菠萝。 牛奶和牛奶制作的奶油：在烹调、咖啡和茶中少量使用。 白软干酪(Cottage Cheese)、酸奶和酸牛乳酒(Kefir)：在烹调或者浇汁中少量使用。 甜味剂：天然甜菊(Stevia)和巧克力（请选择可可含量在70%或者以上的黑巧克力）。 酒：如果你想喝，那么一天一杯，首选红酒。 补剂以及其他建议 补剂：此外需要人们需要从额外的补剂中获取营养，这包含：DHA（一种欧米伽3脂肪酸，存在于鱼油中），白藜芦醇（resveratrol），姜黄（Trumeric or Curcuma longa），椰子油，a-硫辛酸（lipoic acid），维生素D\n禁食：有计划的禁食可以帮助身体消耗储存在内脏中的糖和脂肪，帮助身体更加健康。书中建议一年至少禁食4次，在换季的时候进行（例如，9月、12月、3月以及6月的最后一个星期）。一次24-72小时。禁食期间可以喝大量的水。\n运动：每天要保持至少20分钟的有氧运动。\n其他 该书提出的理念可以作为一个饮食参考，其建议与生酮饮食、地中海饮食有相似之处，低碳水的饮食模式符合现代人的生活方式。然而我认为也不必过于极端地按照上述食谱进食，因为人体所需的部分营养也依赖于部分谷物，找到适合自己的方式最重要。\n","link":"https://mengwoods.github.io/cn/post/hobby/2023-12-08-grain-brain/","section":"post","tags":null,"title":"《谷物大脑》总结"},{"body":"","link":"https://mengwoods.github.io/cn/categories/reading/","section":"categories","tags":null,"title":"Reading"},{"body":"","link":"https://mengwoods.github.io/cn/tags/andriod/","section":"tags","tags":null,"title":"Andriod"},{"body":"","link":"https://mengwoods.github.io/cn/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"","link":"https://mengwoods.github.io/cn/categories/tech/","section":"categories","tags":null,"title":"Tech"},{"body":"Andriod 项目目录各个文件夹功能详细记录\n当使用 Android Studio 新建一个工程时，会出现如下图所示的目录结构：\n自上而下各个文件夹功能的介绍如下：\n.gradle 文件夹是 Gradle 构建系统生成的目录，用于存储构建过程中的各种临时文件和缓存文件。这个目录通常不需要手动干预，Gradle 会自动管理其中的文件。\nGradle 是一种易于使用的构建工具，用于自动化编译、打包、测试和部署软件项目。其支持多种编程语言，包括 Java、Kotlin、Groovy 等。 在安卓开发过程中其可通过一系列构建规则帮助开发 app 的过程。在创建工程时，Android Studio 会根据默认的通用构建规则来完成 app 的构建。 .idea 包含 Android Studio 项目的配置文件，包括项目的工作区设置和其他配置信息，例如工作区布局、运行配置、代码风格等信息。由于这些信息是 IDE 特定的，与项目源代码和构建输出等内容分开存储，因此使用了一个隐藏的目录。文件夹命名源于开发环境 IntelliJ IDEA 的名字。\napp 为项目的主要工作目录，包含项目的源代码以及资源文件，如 app 布局、图像等，以及程序的元数据。\nlibs 用于存放应用程序所使用的第三方库（JAR 文件）。 Java Archive（JAR）是一种压缩文件格式，通常用于将一组相关的类文件、资源文件和元数据打包到一个单独的文件中。 src/androidTest 包含用于执行 Android 测试的代码。这里的测试主要是针对应用程序的功能和用户界面的集成测试。 src/main/java 中包含项目的源代码，通常以包的形式组织在这个目录下。Android 应用的主要逻辑和功能实现都在这里。 src/main/res 中包含资源文件，如 app 布局、字符串、图像等。定义了应用程序的用户界面和其他非代码相关的方面。 src/main/AndroidManifest.xml 应用程序的清单文件，其中包含了有关应用程序的元数据，如应用程序的包名、版本号、权限声明、组件声明（活动、服务、接收器等）等。这个文件是 Android 系统了解应用程序结构和要求的重要文件。 src/test 应用程序的单元测试代码。这里的测试主要是针对应用程序中各个单元（类、方法等）的功能进行测试。 build.gradle 该文件是 Gradle 构建文件，用于配置 app 模块的构建过程。其中包含了应用程序的依赖项、编译选项、签名配置等。 proguard-rules.pro ProGuard 是一个代码缩小（minification）和混淆工具，用于减小 APK 文件的大小并增加安全性。该文件用于配置 ProGuard 规则，指定哪些代码应该被缩小或混淆。 gradle 包含 Gradle 构建系统的配置文件\n其他文件：\n.gitignore Git 版本控制系统的文件，用于排除某个路径，不被 Git 所记录。 .build.gradle 根级别的 Gradle 构建文件，用于配置整个项目的构建过程。这个文件通常包含项目的全局配置，例如项目的名称、版本、仓库地址等。 .gradle.properties 包含一些项目级别的 Gradle 属性配置。可以在这里设置一些全局的 Gradle 配置属性，例如 Gradle 版本、Java 版本等。 .gradlew 和 .gradlew.bat 这是 Gradle Wrapper 的脚本文件，用于在项目中运行 Gradle 而不需要事先安装 Gradle。.gradlew 用于 Unix/Linux 系统，而 .gradlew.bat 用于 Windows 系统。通过运行这些脚本，Gradle 会自动下载和使用指定版本的 Gradle。 local.properties 包含本地配置信息，例如 Android SDK 的路径。这个文件通常是本地特定的。 settings.gradle 包含有关项目模块的配置信息，例如模块的名称。这个文件允许你指定项目中包含哪些模块，以及这些模块的名称。 其他文件夹：\nExternal Libraries 主要包含了项目依赖的外部库和框架的信息。当使用 Gradle 或其他构建工具导入依赖项时，这些依赖项将被列在这里，以便查看、浏览项目所使用的所有外部库的版本和结构。这个视图是一个便捷的方式了解所有第三方库。 Scratches and Consoles 包含了一些临时性的操作的结果，以及控制台（Console）的输出。Scratches 用于创建和保存临时性的代码片段，类似于草稿纸，可以方便地测试一些代码片段或进行快速的实验。Console 包含了各种控制台输出，例如 Gradle 构建过程的输出、运行应用程序时的日志信息等。不同类型的控制台（如 Gradle、Logcat）都会有相应的选项卡，以便查看不同方面的输出 ","link":"https://mengwoods.github.io/cn/post/tech/004-as-folder-functios/cn/","section":"post","tags":["Andriod"],"title":"了解 Andriod Studio 项目目录各文件功能"},{"body":"Google公司的AK-47 在吴军博士《数学之美》一书中的第13章谈到了Google公司的阿米特辛格（Amit Singhal）博士。Singhal博士被誉为是Google的AK-47，因为其经常能够准确地采用简洁的方法并以超高的效率来解决工程中面临的难题。AK-47突击步枪被誉为枪王之王，该枪的显著优点有：结构简单，制造成本低，易上手操作，故障率低，不易损坏，杀伤力大，且适用于多种苛刻的环境。对于战场环境而言，AK-47的优点让它光芒万丈。作者认为在计算机科学行业，一个优秀的算法也应该具备类似AK-47的特点：简洁，有效，可靠性高而且容易被人读懂。\n吴军博士在与Singhal博士在Google共事时期，有一次面对如何解决网络搜索中的作弊问题，这需要组建一个精确的分类器，来准确区分一个搜索是否具有商业意图，从而推测该搜索有多大的可能性包含作弊手段。由于作者深厚的学术经历，面临问题时习惯于寻找一个完美的解决方案，当然这需要耗费大量时间来完成。然而即使设计一个可用的且功能较为完善的分类器，大约也需要三、四个月的时间。此时Singhal博士却提出要使用最简单的可行的方案，这样就能够把工作量急剧减少到一个周末。Singhal博士的工作理念是对于工程问题，最简单实用的方法是最好的方法。在二人采用这个只用了一个周完成的反作弊方法后，一两个月后搜索作弊的数量就减少了一半，并且该分类器非常小巧且运行快速，由于其结构足够的简单，使得后期维护也较为容易。Google公司采用了很久这项技术并最终申请了专利。很明显该方法经得起了时间的考验，并取得了不错的反作弊效果。\n那么为什么在工程中最简单可行的办法会具有不错的实际效果？这个话题是值得探讨的。\n“简单与可行” 在工业领内，最小可行产品（MVP）是一个经常出现的名词。人们在设计产品雏形时，往往按照合同最低要求设计出MVP方案并得以执行，这可以让开发难度和速度得到控制。在MVP实现后再后续进行调优与功能丰富。这种理念可以尽可能地缩短工作进度，让产品迭代速度更快，对产品本身而言，其质量也会随着迭代次数的增加而迅速升高。这应该便是简单可行理念下的产物。\n举一个生活中的“简单可行”例子，想在工作或学习时不被手机吸引从而影响效率，一个简单可行的方法是每次开始工作、学习之前，把手机放到一个你看不到的地方比如衣柜里。这个看似简单的办法往往有出奇的效果，有时工作了一两个小时都不曾有过看一眼手机的念头。这个方法首先足够的简单，简单到没试过的人们会怀疑这是否有真的有效果，其次它并没有从根本上解决人容易被手机吸引的本质，不算完美的解决方案，只能说这个方法解决了大部分问题。然而就是这个简单的方法，在实际生活中有着令人惊讶的效果，若能形成习惯，那么工作、学习的效率会大大提升。我认为这便是一个在生活中符合“简单“与“可行“理念的方法。\n接下来在以下几个方面探讨这种工作中的“简单与可行”理念。\n时间成本 与学术科研活动不同，工程中遇到的问题一般具有时间的紧迫性，这种情况下寻找一个问题的完美解决方案无疑是奢侈的。在如下的不可能三角中，时间少，成本低以及质量高是无法同时实现的。工程问题的解决方案追求的是时间少与成本低，那么就必须放弃对质量的高要求。在这种情况下必须在简单的一系列方法中寻找可行的，即使没有那么完美。这对工作者的要求必须是具备足够的工作经验，才能够在短时间内计划出一个足够简单的方法来尽其可能地解决面临的问题。而对于学术科研来说，其时间限制较少，在漫长的科研过程中，寻求完美的结果便是科研工作者的目标。\n解决效果 那么如果用时较少只使用简单的方案，能否解决实际问题呢？或是能多大程度地解决问题呢？\n当我们去解决一个困难时，所付出的时间和问题解决的程度并不是简单线性相关的关系，而是一个类似Log曲线的模型，如下图，其表示所付出的时间与解决问题的程度的关系。生活中很多事情的发展是符合这个规律的，比如在健身过程中，初期的锻炼肌肉增长速度通常较快，而随着时间推移肌肉增长速度会越来越慢，到了一定阶段后健身只能维持身体的肌肉量。当我们面临一个工程问题时，表面的浅显的问题一般是容易发现与解决的，同时耗时也小，随着简单层级问题的逐步解决，对深层次问题的分析就会变得越来越耗时间。然而当把比较容易解决的问题都解决掉时，实际效果会好一大截。\n如图中A，B，C三点之间的间隔时间相同，而问题解决的程度与投入时间的比例会逐渐下降。若想达到完美结果不知道要付出多少时间，或许永远无法达到。研究学术问题的学者多数处于C之后的阶段，他们投入大量的时间寻找某个领域中接近完美的算法，这也是为什么学术是耗时间的工作。而对于实际工程问题，能够达到A，B附近区域的方案往往会得到青睐，因为其在耗时可接受的情况下效果也不错。\n应用场景 除开众多优点外，AK-47的缺点也有很多：噪声大，后坐力强，外表粗糙不精致，瞄准精度低等，然而一把冲锋枪在战场上首先要保证的是不容易坏，且杀伤力强。满足了这两点后，其他方面甚至是可以不需过多考虑的。所以在解决实际问题时，应用场景也是需要考虑的。如果提出一个简洁的方法，但其可以最需要关注的方面进行一些改善调优，那么它便是在该应用场景下行之有效的方法。完美的方案除开时间成本之外，其可能在众多方面对系统进行全棉的改善，但在最需要关注的方面上，其效果可能并不比简单方法优秀多少。所以在针对应用场景上，使用简单的方法是高效的。\n可靠性 简单的方法之所以简单，是因为其逻辑步骤清晰，多数人容易理解。这带来的是维护便捷，维护人员不需要太高的知识储备。任何软件都需要随时间进行迭代，以修复Bug和提高软件的可靠性。而完美的深入的方法需要更多的知识储备，容易造成难以理解，这对工程项目来说，不利于日后的维护，维护成本也比较高。容易维护的方法在可靠性上是更高的。\n深奥的简洁 我们所学习过的物理公式如牛顿三大定律、爱因斯坦质能方程等，简洁地描述了这个世界的运行规律。这种简洁表达的背后是作者深厚的功底、无数次实验与思考的结果。对于本文例子中的“简单方法“，是Google公司知名博士口中的“简单”，其含义可能与普通人理解的“简单”并不相同。\n简单方法若想得到最佳效果，要保证其在某一方面带来效果的同时，不会在其它方面影响系统的正常运行。顾此失彼的简单方法不会是好方法。这意味着无论如何，都需要具有足够的知识储备与全局的把控能力才能提出工程中切实可行的简单方法。似乎使用“合适的方法”更为精准，简单只是它所表现出来的一个特征。让追求完美、持续学习与思考成为一种习惯，这样在面对实际工作问题时，才能够举重若轻、拨冗求简，寻求所谓的“简单”。\n","link":"https://mengwoods.github.io/cn/post/hobby/2023-11-15-beauty-of-math/cn/","section":"post","tags":null,"title":"《数学之美》中的Amit Singhal博士的工作理念"},{"body":"","link":"https://mengwoods.github.io/cn/categories/docker/","section":"categories","tags":null,"title":"Docker"},{"body":"Guitar Scores\n老婆给我分享的一首歌，听了后感觉心旷神怡，她说是在北欧冷冰冰视频里听到的。磁性的嗓音与舒服的吉他配乐，让我有种轻松自在旅行在各个国家的感觉，意往神驰。突然有种冲动，想练会吉他，把它唱出来，最好再录成一首自己的MV，配上一些美丽的风景，想想很酷很年轻。\nhttps://music.youtube.com/watch?v=cUSfUpEEykU\n1 2[Verse] 3D 4Hey darling 5 G D 6Can I tell you whats been on my mind 7 G D A Asus4 A 8Sick and tired of the nine to five and the city lights 9 10 11[Verse] 12D 13Hey darling 14G D 15We could get out of town 16 G D A Asus4 A 17See the beautiful world around, wanna see it now 18 19 20[Pre-Chorus] 21Bm A D G 22Pack our bags and get in the car 23Bm A D G 24Leave a little note and we\u0026#39;ll drive real far 25 26 27[Chorus] 28 G D 29Let\u0026#39;s get out, we can leave this city 30 A Bm 31Let\u0026#39;s drive to the open air 32 G D 33Yeah, the countryside is so pretty 34 A Bm 35With the wind blowing in your hair 36G D 37We can look back someday 38A Bm 39Baby, don\u0026#39;t you understand? 40 G D 41That we only get one love I wanna make it count 42 A D 43Honey, come on now and take my hand 44 45 46[Verse] 47D 48Hey darling 49 G D 50I love it when it\u0026#39;s me and you 51 G D A Asus4 A 52On the road with a couple tunes and a car for two 53 54 55[Verse] 56D 57Hey darling 58 G D 59You know we\u0026#39;re gonna have a really good time 60G D 61Driving in the middle of the night 62 A Asus4 A 63When the stars are bright 64 65 66[Pre-Chorus] 67Bm A D G 68Pack our bags and get in the car 69Bm A D G 70Leave a little note and we\u0026#39;ll drive real far 71 72 73[Chorus] 74 G D 75Let\u0026#39;s get out, we can leave this city 76 A Bm 77Let\u0026#39;s drive to the open air 78 G D 79Yeah, the countryside is so pretty 80 A Bm 81With the wind blowing in your hair 82G D 83We can look back someday 84A Bm 85Baby, don\u0026#39;t you understand? 86 G D 87That we only get one love I wanna make it count 88 A D 89Honey, come on now and take my hand 90 91 92[Bridge] 93Bm A D G 94Uhh uhh uhh uhhhhh 95Bm A D G 96Uhh uhh uhh uhhhhh 97 98 99[Chorus] 100 G D 101Let\u0026#39;s get out, we can leave this city 102 A Bm 103Let\u0026#39;s drive to the open air 104 G D 105Yeah, the countryside is so pretty 106 A Bm 107With the wind blowing in your hair 108G D 109We can look back someday 110A Bm 111Baby, don\u0026#39;t you understand? 112 G D 113That we only get one love I wanna make it count 114 A Bm 115Honey, come on now and take my hand 116 G D 117Yeah we only get one love I wanna make it count 118 A D 119Honey, come on now and take my hand ","link":"https://mengwoods.github.io/cn/post/hobby/2024-05-13-honey-take-my-hand/","section":"post","tags":null,"title":"Honey Take My Hnad Lyrics"},{"body":"","link":"https://mengwoods.github.io/cn/categories/ai/","section":"categories","tags":null,"title":"AI"},{"body":"","link":"https://mengwoods.github.io/cn/tags/hugo/","section":"tags","tags":null,"title":"Hugo"},{"body":"","link":"https://mengwoods.github.io/cn/categories/web/","section":"categories","tags":null,"title":"Web"},{"body":"","link":"https://mengwoods.github.io/cn/series/","section":"series","tags":null,"title":"Series"}]